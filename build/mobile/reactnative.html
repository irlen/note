<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>react-native - 欢迎使用Teadocs文档生成系统</title><meta name="description" content="创建一个stackNavigatorconst Stack = createStackNavigator();"><meta name="keywords" content="react-native - 欢迎使用Teadocs文档生成系统"><script src="/static/js/jquery-3.3.1.min.js"></script><script src="/static/js/vue.min.js"></script><link rel="stylesheet" href="/static/css/normalize.min.css"><link rel="stylesheet" href="/static/css/monaco.css"><link rel="stylesheet" href="/static/css/loading.css"><link rel="stylesheet" href="/static/css/editormd.min.css"><link rel="stylesheet" href="/static/css/style.css"><link rel="stylesheet" href="/static/css/mobile.css"><link rel="stylesheet" href="/static/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/static/css/highlight.default.min.css"><script src="/static/js/highlight.min.js"></script><script>window._CONST={ROOT_PATH:"/"},hljs.initHighlightingOnLoad()</script></head><body><div class="main"><div class="tea-menu"><div class="tea-menu-title"><i class="fa fa-home" aria-hidden="true"></i> <span>欢迎使用Teadocs文档生成系统</span></div><div class="tea-menu-search-warp"><i class="fa fa-search"></i> <input type="text" placeholder="搜索文档" value height="100%"></div><ul class="tea-menu-list"><li><a href="/index.html" title="介绍">介绍</a></li><li><a title="大前端">大前端<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a title="react">react<i class="fa fa-angle-down"></i></a><ul><li><a href="/front/react/react-hooks.html" title="react-hooks">react-hooks</a></li></ul></li><li><a title="vue">vue<i class="fa fa-angle-down"></i></a><ul><li><a href="/front/vue/project.html" title="vue工程">vue工程</a></li><li><a href="/front/vue/vuebase.html" title="vue基础语法">vue基础语法</a></li></ul></li></ul></li><li><a title="移动端" class="active">移动端<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/mobile/reactnative.html" title="react-native" class="active">react-native</a></li></ul></li><li><a title="数据库">数据库<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/database/mysql.html" title="mysql">mysql</a></li></ul></li><li><a title="java">java<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/java/mybatis.html" title="mybatis">mybatis</a></li><li><a href="/java/springboot.html" title="SpringBoot">SpringBoot</a></li><li><a href="/java/annotation.html" title="annotation">annotation</a></li><li><a href="/java/method.html" title="常用方法">常用方法</a></li><li><a href="/java/api.html" title="常用api">常用api</a></li><li><a href="/java/login.html" title="登录验证方式">登录验证方式</a></li></ul></li><li><a title="微信小程序">微信小程序<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/wechat/wechat.html" title="微信小程序">微信小程序</a></li><li><a href="/wechat/wxtrade.html" title="微信授权及支付">微信授权及支付</a></li></ul></li><li><a title="Bash脚本">Bash脚本<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/bash/introduce.html" title="简介">简介</a></li></ul></li><li><a title="git">git<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/git/git.html" title="git">git</a></li></ul></li><li><a title="运维">运维<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/ops/docker.html" title="docker">docker</a></li><li><a href="/ops/nginx.html" title="nginx">nginx</a></li><li><a href="/ops/linux.html" title="linux">linux</a></li></ul></li><li><a title="正则">正则<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/regexp/regexp.html" title="正则">正则</a></li></ul></li></ul><div class="tea-version"><p>version: 0.0.1</p><p>Built with <a href="https://github.com/lisniuse/teadocs" target="_blank">Teadocs</a></p></div></div><div class="tea-content"><div class="tea-nav"><h3 class="top-title" style="font-weight:500;margin:0;font-size:16px"><i class="fa fa-navicon" aria-hidden="true"></i> <span>react-native</span></h3><div class="article-meta"></div></div><div class="tea-container"><article class="markdown-body"><h3 id="react-navigation"><a href="#react-navigation" class="header-anchor">#</a> <span>react navigation</span></h3><p>创建一个stackNavigator<br>const Stack = createStackNavigator();</p><pre class="prettyprint"><code>&lt;Stack.Navigator initialRouteName="Home"&gt;
  &lt;Stack.Screen name="Home" component={HomeScreen} options={{title:'Over view'}} /&gt;
  &lt;Stack.Screen name="Details" component={DetailsScreen} /&gt;
&lt;/Stack.Navigator&gt;</code></pre><p>屏幕之间跳转 navigate</p><pre class="prettyprint"><code>&lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt;
  &lt;Text&gt;Home Screen&lt;/Text&gt;
  &lt;Button
    title="Go to Details"
    onPress={() =&gt; navigation.navigate('Details')}
  /&gt;
&lt;/View&gt;
或者
&lt;Button
  title="Go to Details... again"
  onPress={() =&gt; navigation.push('Details')} //Details是Screen组件的name 属性
/&gt;
</code></pre><p>返回<br>当可以从活动屏幕返回时，堆栈导航器提供的标题将自动包含一个后退按钮（如果导航堆栈中只有一个屏幕，则无法返回任何内容，因此没有返回键）。</p><pre class="prettyprint"><code>&lt;Button title="Go back" onPress={() =&gt; navigation.goBack()} /&gt;</code></pre><p>返回到第一个屏幕</p><pre class="prettyprint"><code>&lt;Button
  title="Go back to first screen in stack"
  onPress={() =&gt; navigation.popToTop()}
/&gt;</code></pre><h3 id="路由间的参数传递"><a href="#路由间的参数传递" class="header-anchor">#</a> <span>路由间的参数传递</span></h3><p>这有两部分：</p><p>1.通过将参数放入对象作为navigation.navigate函数的第二个参数，将参数传递给路线：navigation.navigate('RouteName', { params go here })</p><p>2.阅读屏幕组件中的参数：route.params。</p><pre class="prettyprint"><code>//携带参数
&lt;Button
  title="Go to Details"
  onPress={() =&gt; {
    /* 1. Navigate to the Details route with params */
    navigation.navigate('Details', {
      itemId: 86,
      otherParam: 'anything you want here',
    });
  }}
/&gt;
//读取参数
const params = route.params;
const { itemId,otherParam } = params;
&lt;Text&gt;itemId: {JSON.stringify(itemId)}&lt;/Text&gt;
&lt;Text&gt;otherParam: {JSON.stringify(otherParam)}&lt;/Text&gt;
//更新屏幕参数
navigation.setParams()
//若未指定参数则使用默认参数
&lt;Stack.Screen
  name="Details"
  component={DetailsScreen}
  initialParams={{ itemId: 42 }}
/&gt;</code></pre><p>将参数回传到上一个屏幕<br>参数不仅对将某些数据传递到新屏幕很有用，而且对将数据传递到前一个屏幕也很有用。例如，假设您有一个带有创建帖子按钮的屏幕，并且创建帖子按钮会打开一个新屏幕以创建帖子。创建帖子后，您想要将帖子的数据传递回上一屏幕。</p><pre class="prettyprint"><code>&lt;&gt;
  &lt;TextInput
    multiline
    placeholder="What's on your mind?"
    style={{ height: 200, padding: 10, backgroundColor: 'white' }}
    value={postText}
    onChangeText={setPostText}
  /&gt;
  &lt;Button
    title="Done"
    onPress={() =&gt; {
      // Pass params back to home screen
      navigation.navigate('Home', { post: postText });
    }}
  /&gt;
&lt;/&gt;
</code></pre><p>将参数传递给嵌套导航器<br>如果您有嵌套的导航器，则需要以不同的方式传递参数。例如，假设您在Account屏幕内有一个导航器，并且想将参数传递给该导航器内的屏幕Settings。然后，您可以按以下方式传递参数：</p><pre class="prettyprint"><code>navigation.navigate('Account', {
  screen: 'Settings',
  params: { user: 'jane' },
});</code></pre><h3 id="配置栏标题"><a href="#配置栏标题" class="header-anchor">#</a> <span>配置栏标题</span></h3><pre class="prettyprint"><code>&lt;Stack.Screen
  name="Profile"
  component={ProfileScreen}
  options={({ route }) =&gt; ({ title: route.params.name })}
/&gt;

传递给options函数的参数是具有以下属性的对象：
navigation- 屏幕的导航道具。
route- 屏幕的路由道具</code></pre><p>更新options和setOptions<br><Button<br>title="Update the title"<br>onPress={() => navigation.setOptions({ title: 'Updated!' })}<br>/></p><p>标题样式<br>定制你的头的风格时，有三个关键性能用途：headerStyle，headerTintColor，和headerTitleStyle。</p><p>headerStyle：一种样式对象，该样式对象将应用于View封装标题的。如果设置backgroundColor了它，那将是标题的颜色。<br>headerTintColor：后退按钮和标题都使用此属性作为其颜色。在下面的示例中，我们将颜色设置为白色（#fff），因此后退按钮和标题标题将为白色。<br>headerTitleStyle：如果要自定义标题的fontFamily，fontWeight以及其他Text样式属性，可以使用它来完成。</p><p>options 跨屏幕共享</p><p>将配置上移到prop下的堆栈导航器screenOptions</p><pre class="prettyprint"><code>function StackScreen() {
  return (
    &lt;Stack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: '#f4511e',
        },
        headerTintColor: '#fff',
        headerTitleStyle: {
          fontWeight: 'bold',
        },
      }}
    &gt;
      &lt;Stack.Screen
        name="Home"
        component={HomeScreen}
        options={{ title: 'My home' }}
      /&gt;
    &lt;/Stack.Navigator&gt;
  );
}</code></pre><p>自定义标题组件headerTitle</p><pre class="prettyprint"><code>function LogoTitle() {
  return (
    &lt;Image
      style={{ width: 50, height: 50 }}
      source={require('@expo/snack-static/react-native-logo.png')}
    /&gt;
  );
}

function StackScreen() {
  return (
    &lt;Stack.Navigator&gt;
      &lt;Stack.Screen
        name="Home"
        component={HomeScreen}
        options={{ headerTitle: props =&gt; &lt;LogoTitle {...props} /&gt; }}
      /&gt;
    &lt;/Stack.Navigator&gt;
  );
}</code></pre><p>您可能想知道，为什么headerTitle当我们提供组件而不是title像以前那样提供组件？原因是这headerTitle是特定于堆栈导航器的属性，headerTitle默认为Text显示的组件title。</p><h3 id="向标题添加按钮"><a href="#向标题添加按钮" class="header-anchor">#</a> <span>向标题添加按钮</span></h3><p>在标题的右侧添加一个按钮</p><pre class="prettyprint"><code>function StackScreen() {
  return (
    &lt;Stack.Navigator&gt;
      &lt;Stack.Screen
        name="Home"
        component={HomeScreen}
        options={{
          headerTitle: props =&gt; &lt;LogoTitle {...props} /&gt;,
          headerRight: () =&gt; (
            &lt;Button
              onPress={() =&gt; alert('This is a button!')}
              title="Info"
              color="#fff"
            /&gt;
          ),
        }}
      /&gt;
    &lt;/Stack.Navigator&gt;
  );
}</code></pre><p>页头元素说屏幕组件的交互<br>我们需要使用navigation.setOptions定义按钮而不是optionsprop</p><pre class="prettyprint"><code>function StackScreen() {
  return (
    &lt;Stack.Navigator&gt;
      &lt;Stack.Screen
        name="Home"
        component={HomeScreen}
        options={({ navigation, route }) =&gt; ({
          headerTitle: props =&gt; &lt;LogoTitle {...props} /&gt;,
        })}
      /&gt;
    &lt;/Stack.Navigator&gt;
  );
}

function HomeScreen({ navigation }) {
  const [count, setCount] = React.useState(0);

  React.useLayoutEffect(() =&gt; {
    navigation.setOptions({
      headerRight: () =&gt; (
        &lt;Button onPress={() =&gt; setCount(c =&gt; c + 1)} title="Update count" /&gt;
      ),
    });
  }, [navigation, setCount]);

  return &lt;Text&gt;Count: {count}&lt;/Text&gt;;
}</code></pre><p>自定义后退按钮<br>createStackNavigator提供后退按钮特定于平台的默认设置。在iOS上，按钮旁边包含一个标签，当标题适合可用空间时，该标签会显示前一个屏幕的标题，否则显示“返回”。</p><p>您可以使用headerBackTitle和headerTruncatedBackTitle，要自定义后退按钮图像，可以使用headerBackImage。</p><h3 id="嵌套导航"><a href="#嵌套导航" class="header-anchor">#</a> <span>嵌套导航</span></h3><p>嵌套导航意味着在另一个导航器的屏幕内渲染一个导航器</p><pre class="prettyprint"><code>function Home() {
  return (
    &lt;Tab.Navigator&gt;
      &lt;Tab.Screen name="Feed" component={Feed} /&gt;
      &lt;Tab.Screen name="Messages" component={Messages} /&gt;
    &lt;/Tab.Navigator&gt;
  );
}

function App() {
  return (
    &lt;NavigationContainer&gt;
      &lt;Stack.Navigator&gt;
        &lt;Stack.Screen name="Home" component={Home} /&gt;
        &lt;Stack.Screen name="Profile" component={Profile} /&gt;
        &lt;Stack.Screen name="Settings" component={Settings} /&gt;
      &lt;/Stack.Navigator&gt;
    &lt;/NavigationContainer&gt;
  );
}</code></pre><p>每个导航器都有自己的导航历史记录，当在某个屏幕中调用navigation.goBack()时，会返回当前当前导航器的上一个页面，navigate到某个页面，如果页面不在改子导航内，则父导航将会处理。</p><p>嵌套导航器不接收父项的事件<br>例如，如果您在选项卡导航器中嵌套了一个堆栈导航器，则使用时，堆栈导航器中的屏幕将不会接收父选项卡导航器发出的事件，例如（tabPress）navigation.addListener。要从父级导航器接收事件，可以使用显式侦听父级的事件navigation.dangerouslyGetParent().addListener。</p><p>指定子导航的显示屏幕</p><pre class="prettyprint"><code>复制
function Root() {
  return (
    &lt;Stack.Navigator&gt;
      &lt;Stack.Screen name="Profile" component={Profile} /&gt;
      &lt;Stack.Screen name="Settings" component={Settings} /&gt;
    &lt;/Stack.Navigator&gt;
  );
}
//指定嵌套导航呈现的页面
navigation.navigate('Root', { screen: 'Settings' });
//将参数传递给嵌套导航屏幕
navigation.navigate('Root', {
  screen: 'Settings',
  params: { user: 'jane' },
});
//对于深层嵌套导航，可以这样传递
navigation.navigate('Root', {
  screen: 'Settings',
  params: {
    screen: 'Sound',
    params: {
      screen: 'Media',
    },
  },
});</code></pre><h3 id="导航的生命周期"><a href="#导航的生命周期" class="header-anchor">#</a> <span>导航的生命周期</span></h3><p>每个导航器的首屏被访问后将会被保留状态，当离开时并不执行componentWillUnmount();</p><p>捕捉导航生命周期状态<br>订阅是否聚焦当前页面</p><pre class="prettyprint"><code>function Profile({ navigation }) {
  React.useEffect(() =&gt; {
    const unsubscribe = navigation.addListener('focus', () =&gt; {
      // Screen was focused
      // Do something
    });

    return unsubscribe;
  }, [navigation]);

  return &lt;ProfileContent /&gt;;
}


代替手动添加事件侦听器，我们可以使用useFocusEffect挂钩执行副作用。就像React的useEffect钩子一样，但它与导航生命周期息息相关。

例：
import { useFocusEffect } from '@react-navigation/native';

function Profile() {
  useFocusEffect(
    React.useCallback(() =&gt; {
      // Do something when the screen is focused

      return () =&gt; {
        // Do something when the screen is unfocused
        // Useful for cleanup functions
      };
    }, [])
  );

  return &lt;ProfileContent /&gt;;
}
</code></pre><h3 id="打开全屏模式"><a href="#打开全屏模式" class="header-anchor">#</a> <span>打开全屏模式</span></h3><p>...</p></article><div class="page"><a class="page-prev" href="/front/vue/vuebase.html"><i class="fa fa-arrow-left" aria-hidden="true"></i> vue基础语法 </a><a class="page-next" href="/database/mysql.html">mysql <i class="fa fa-arrow-right" aria-hidden="true"></i></a></div><div class="toc"><ul class="toc-affix"><li class="toc-item text-elli" style="padding-left:15px" data-link="react-navigation"><a href="#react-navigation" title="react navigation">react navigation</a></li><li class="toc-item text-elli" style="padding-left:15px" data-link="路由间的参数传递"><a href="#路由间的参数传递" title="路由间的参数传递">路由间的参数传递</a></li><li class="toc-item text-elli" style="padding-left:15px" data-link="配置栏标题"><a href="#配置栏标题" title="配置栏标题">配置栏标题</a></li><li class="toc-item text-elli" style="padding-left:15px" data-link="向标题添加按钮"><a href="#向标题添加按钮" title="向标题添加按钮">向标题添加按钮</a></li><li class="toc-item text-elli" style="padding-left:15px" data-link="嵌套导航"><a href="#嵌套导航" title="嵌套导航">嵌套导航</a></li><li class="toc-item text-elli" style="padding-left:15px" data-link="导航的生命周期"><a href="#导航的生命周期" title="导航的生命周期">导航的生命周期</a></li><li class="toc-item text-elli" style="padding-left:15px" data-link="打开全屏模式"><a href="#打开全屏模式" title="打开全屏模式">打开全屏模式</a></li></ul></div></div></div><i class="fa fa-arrow-circle-up gotop" aria-hidden="true"></i><div id="menu-mask"></div></div><script src="/data.js"></script><script src="/static/js/main.js"></script><script src="/static/js/mobile.js"></script>
<script src="/__webscoket__/socket.io.js"></script>
<script src="/__webscoket__/socket.client.js"></script>
</body></html>
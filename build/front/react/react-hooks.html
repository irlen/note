<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>react-hooks - 欢迎使用Teadocs文档生成系统</title><meta name="description" content="为什么只能在函数最外层调用 Hook，不要在循环、条件判断或者子函数中调用？为什么 useEffect 第二个参数是空数组，就相当于 ComponentDidMount ，只会执行一次？React Hooks 分为内置的和自定义的两种类型，内置的 hooks 有以下几个："><meta name="keywords" content="react-hooks - 欢迎使用Teadocs文档生成系统"><script src="/static/js/jquery-3.3.1.min.js"></script><script src="/static/js/vue.min.js"></script><link rel="stylesheet" href="/static/css/normalize.min.css"><link rel="stylesheet" href="/static/css/monaco.css"><link rel="stylesheet" href="/static/css/loading.css"><link rel="stylesheet" href="/static/css/editormd.min.css"><link rel="stylesheet" href="/static/css/style.css"><link rel="stylesheet" href="/static/css/mobile.css"><link rel="stylesheet" href="/static/font-awesome-4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/static/css/highlight.default.min.css"><script src="/static/js/highlight.min.js"></script><script>window._CONST={ROOT_PATH:"/"},hljs.initHighlightingOnLoad()</script></head><body><div class="main"><div class="tea-menu"><div class="tea-menu-title"><i class="fa fa-home" aria-hidden="true"></i> <span>欢迎使用Teadocs文档生成系统</span></div><div class="tea-menu-search-warp"><i class="fa fa-search"></i> <input type="text" placeholder="搜索文档" value height="100%"></div><ul class="tea-menu-list"><li><a href="/index.html" title="介绍">介绍</a></li><li><a title="大前端" class="active">大前端<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a title="react" class="active">react<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/front/react/react-hooks.html" title="react-hooks" class="active">react-hooks</a></li></ul></li><li><a title="vue">vue<i class="fa fa-angle-down"></i></a><ul><li><a href="/front/vue/project.html" title="vue工程">vue工程</a></li><li><a href="/front/vue/vuebase.html" title="vue基础语法">vue基础语法</a></li></ul></li></ul></li><li><a title="数据库">数据库<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/database/mysql.html" title="mysql">mysql</a></li></ul></li><li><a title="java">java<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/java/mybatis.html" title="mybatis">mybatis</a></li><li><a href="/java/springboot.html" title="SpringBoot">SpringBoot</a></li><li><a href="/java/annotation.html" title="annotation">annotation</a></li></ul></li><li><a title="Bash脚本">Bash脚本<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/bash/introduce.html" title="简介">简介</a></li></ul></li><li><a title="运维">运维<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/ops/docker.html" title="docker">docker</a></li></ul></li><li><a title="正则">正则<i class="fa fa-angle-down unfold"></i></a><ul class="unfold"><li><a href="/regexp/regexp.html" title="正则">正则</a></li></ul></li></ul><div class="tea-version"><p>version: 0.0.1</p><p>Built with <a href="https://github.com/lisniuse/teadocs" target="_blank">Teadocs</a></p></div></div><div class="tea-content"><div class="tea-nav"><h3 class="top-title" style="font-weight:500;margin:0;font-size:16px"><i class="fa fa-navicon" aria-hidden="true"></i> <span>react-hooks</span></h3><div class="article-meta"></div></div><div class="tea-container"><article class="markdown-body"><h3 id="react-hooks"><a href="#react-hooks" class="header-anchor">#</a> <span>react-hooks</span></h3><p>为什么只能在函数最外层调用 Hook，不要在循环、条件判断或者子函数中调用？<br>为什么 useEffect 第二个参数是空数组，就相当于 ComponentDidMount ，只会执行一次？<br>React Hooks 分为内置的和自定义的两种类型，内置的 hooks 有以下几个：</p><h3 id="Basic-Hooks"><a href="#Basic-Hooks" class="header-anchor">#</a> <span>Basic Hooks</span></h3><p>useState<br>useEffect<br>useContext</p><h3 id="Additional-HooksuseReducer"><a href="#Additional-HooksuseReducer" class="header-anchor">#</a> <span>Additional HooksuseReducer</span></h3><p>useCallback<br>useMemo<br>useRef<br>useImperativeHandle<br>useLayoutEffect<br>useDebugValue</p><h3 id="1.useState"><a href="#1.useState" class="header-anchor">#</a> <span>1.useState</span></h3><p>const [count,setCount] = useState(0);<br>setCount(),可直接输入要设置的值，也可以传入带参数函数，参数为上一次count值，经过计算处理返回。</p><pre class="prettyprint"><code>  setCount(previous=&gt;{
    return revious+10
  })</code></pre><p>注意： useState 的参数可以是基本类型，也可以是对象类型，在更新对象类型时，切记要合并旧的状态，否则旧的状态会丢失</p><pre class="prettyprint"><code>setCount({
  ...params,
  countone: 200
})</code></pre><h3 id="2.useEffect/useLayoutEffect"><a href="#2.useEffect/useLayoutEffect" class="header-anchor">#</a> <span>2.useEffect/useLayoutEffect</span></h3><p>useEffect是ReactHooks的核心,可取代componentDidMount、componentDidUpdate、componentWillUnmount三个周期。<br>useEffect接受两个参数，其中第二个参数是可选的，不过一般情况下都需要传入第二个参数。</p><pre class="prettyprint"><code>useEffect(()=&gt;{

    return ()=&gt;{}
},[])</code></pre><p>第一个参数为一个函数，为必传参数，当组件数次渲染或者其依赖的状态改变时会执行，该函数的返回值是可选的，可以不写，如果要写的话必须是一个函数，用于清除上一个状态。</p><p>第二个参数为可选参数，是一个数组。数组中可以传入状态值（通过useState产生的值），当状态值改变的时候首先会执行return函数（即第一个参数中函数的返回值函数），用于清理上一个状态，然后useEffect中的函数就会再次执行。</p><p>***如果不传入第二个参数，代表组件中任何状态的改变，effect都会执行一次，这通常不是我们想要的行为。</p><p>***如果第二个参数传递一个空数组，代表efffect只会执行一次，相当于componentDidmount,return函数也只会在组件卸载的时候执行一次，相当于componentWillUnmount。</p><p>***如果第二个参数数组中有一个或者多个状态值，那么只要有任意一个状态值发生变化，该effect都会再次执行。相当于componentDidUpdate。</p><p>***useEffect是在组件状态改变之后，并且在组件layout和paint之后，也就是说组件出现在页面后再进行调用，useLayoutEffect是在组件状态改变后，但是在组件layout和paint之前，也就是在组件出现在页面之前进行调用。</p><p>***useEffect是异步的，useLayoutEffect是同步的。useEffect不会堵塞主线程渲染。</p><h3 id="3.useRef"><a href="#3.useRef" class="header-anchor">#</a> <span>3.useRef</span></h3><pre class="prettyprint"><code>function xxx(){
  const inputRef = useRef(null);
  useEffect(()=&gt;{
      inputRef.current.value = 'hello'
  },[])
  return (
      &lt;input type="text" ref={inputRef} /&gt;
  )
}</code></pre><p>useRef 接收一个初始值，返回一个可变的ref对象，ref.current指向初始化的值。它可以指向别的值。<br>由于是函数组件，this不再指向这个组件，所以要达到class组件中实例变量的效果，可以通过useRef来实现。<br>如果你的 effect 返回一个函数，React 将会在执行清除操作时调用它：<br>为什么 effect 的清除阶段在每次重新渲染时都会执行，而不是只在卸载组件的时候执行一次。让我们看一个实际的例子，看看为什么这个设计可以帮助我们创建 bug 更少的组件。</p><h3 id="4.useContext"><a href="#4.useContext" class="header-anchor">#</a> <span>4.useContext</span></h3><p>useContext的参数必须是context本身；<br>设置context , const ThemContext = React.createContext(themes.light);<br>const value = useContext(MyContext);<br>因为没有static的限制，同一个组件中可以使用多个useContext。也就是说，可以使用多个上层组件传递来的数据。</p><h3 id="5.useReducer"><a href="#5.useReducer" class="header-anchor">#</a> <span>5.useReducer</span></h3><p>提到reducer，首先想到的应该是redux中的reducer。useReducer这个hook与redux中的reducer有所相似又有所不同。可以查看demo中的useReducer。<br>const [state, dispatch] = useReducer(reducer,initialState);<br>要预先写好reducer。<br>dipatch({type:'ADD'});<br>与redux中的reducer有所不同的是，useReducer中的reducer是独立的。如果有多个组件使用到了同一个reducer，那么它们之间的状态是独立的。相较于redux的全局共享状态，它还依赖于react-redux提供的Provider组件。<br>所以是不是突然想到了第四点中的Context，它提供了Provider。如果能配合useReducer，就可以实现全局状态共享了？确实如此！</p><h3 id="6.useImperativeHandle"><a href="#6.useImperativeHandle" class="header-anchor">#</a> <span>6.useImperativeHandle</span></h3><p>useImperativeHandle这个hook是ref的另一种写法。现在通过这个hook可以在子组件中暴露一些API供父组件调用。而父组件是不能直接操作子组件的dom元素的。</p><h3 id="7.useCallback"><a href="#7.useCallback" class="header-anchor">#</a> <span>7.useCallback</span></h3><p>父组件通过props传给子组件一个函数，这个函数用到父组件中的state,如果state改变的时候， memo子组件不会检测到属性的变化，useCallback就是为了解决这一问题，它缓存了一个函数，并接受一系列依赖项，返回一个函数，如果依赖项变化，函数变化。</p><pre class="prettyprint"><code>const handleChange =useCallback (()=&gt;{
        setResult(count + 1);  //count为父组件的一个state
},[count])
//子组件
&lt;Children  onChange={handleChange} /&gt;</code></pre><h3 id="8.useMemo"><a href="#8.useMemo" class="header-anchor">#</a> <span>8.useMemo</span></h3><p>useMomo用来缓存一个复杂的计算值，useCallback(fn,deps)等价于useMomo(()=>fn,deps)。如果通过一个输入得到一个值需要经过复杂的计算，那么下次同样的输入再进行一遍同样复杂的计算是没有必要的。这就是useMemo的意义。<br>const result = useMemo(()=>computedExpensiveValue(40),[count]);<br>const result = computedExpensiveValue(40);<br>重新计算result的时候，如果count值没变，就直接从缓存里面读取，避免性能消耗。</p><p>9.useDebugValue</p><p>通常来说你不需要它。它只会存在于自定义的hooks中用来标志一个自定义的hooks。当在chrome中打开react扩展时候，如果一个组件使用到了自定义的hooks，并且该hooks使用到了useDebugValue，那么该组件下方会显示useDebugValue传入的参数。</p><pre class="prettyprint"><code>  function useUserInfo() {
    // ...
    useDebugValue('use-user-info');
    return userInfo;
  }
</code></pre></article><div class="page"><a class="page-prev" href="/index.html"><i class="fa fa-arrow-left" aria-hidden="true"></i> 介绍 </a><a class="page-next" href="/front/vue/project.html">vue工程 <i class="fa fa-arrow-right" aria-hidden="true"></i></a></div><div class="toc"><ul class="toc-affix"><li class="toc-item text-elli" style="padding-left:15px" data-link="react-hooks"><a href="#react-hooks" title="react-hooks">react-hooks</a></li><li class="toc-item text-elli" style="padding-left:15px" data-link="Basic-Hooks"><a href="#Basic-Hooks" title="Basic Hooks">Basic Hooks</a></li><li class="toc-item text-elli" style="padding-left:15px" data-link="Additional-HooksuseReducer"><a href="#Additional-HooksuseReducer" title="Additional HooksuseReducer">Additional HooksuseReducer</a></li><li class="toc-item text-elli" style="padding-left:15px" data-link="1.useState"><a href="#1.useState" title="1.useState">1.useState</a></li><li class="toc-item text-elli" style="padding-left:15px" data-link="2.useEffect/useLayoutEffect"><a href="#2.useEffect/useLayoutEffect" title="2.useEffect/useLayoutEffect">2.useEffect/useLayoutEffect</a></li><li class="toc-item text-elli" style="padding-left:15px" data-link="3.useRef"><a href="#3.useRef" title="3.useRef">3.useRef</a></li><li class="toc-item text-elli" style="padding-left:15px" data-link="4.useContext"><a href="#4.useContext" title="4.useContext">4.useContext</a></li><li class="toc-item text-elli" style="padding-left:15px" data-link="5.useReducer"><a href="#5.useReducer" title="5.useReducer">5.useReducer</a></li><li class="toc-item text-elli" style="padding-left:15px" data-link="6.useImperativeHandle"><a href="#6.useImperativeHandle" title="6.useImperativeHandle">6.useImperativeHandle</a></li><li class="toc-item text-elli" style="padding-left:15px" data-link="7.useCallback"><a href="#7.useCallback" title="7.useCallback">7.useCallback</a></li><li class="toc-item text-elli" style="padding-left:15px" data-link="8.useMemo"><a href="#8.useMemo" title="8.useMemo">8.useMemo</a></li></ul></div></div></div><i class="fa fa-arrow-circle-up gotop" aria-hidden="true"></i><div id="menu-mask"></div></div><script src="/data.js"></script><script src="/static/js/main.js"></script><script src="/static/js/mobile.js"></script>
<script src="/__webscoket__/socket.io.js"></script>
<script src="/__webscoket__/socket.client.js"></script>
</body></html>
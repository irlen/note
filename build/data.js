(function () {
  var content = [{"context":[{"title":"介绍","link":"/index.html"}],"content":"\n        <h3 id=\"此文档主要用于学习记录\">\n            <a href='#此文档主要用于学习记录' class='header-anchor'>#</a>\n            <span>此文档主要用于学习记录</span>\n        </h3>\n    <p>最近修改于2020年03月23日<br>github地址：<a href=\"https://github.com/irlen/note\">https://github.com/irlen/note</a></p>\n"},{"context":[{"title":"大前端","link":"javascript:void(0)"},{"title":"react","link":"javascript:void(0)"},{"title":"react-hooks","link":"/front/react/react-hooks.html"}],"content":"\n        <h3 id=\"react-hooks\">\n            <a href='#react-hooks' class='header-anchor'>#</a>\n            <span>react-hooks</span>\n        </h3>\n    <p>为什么只能在函数最外层调用 Hook，不要在循环、条件判断或者子函数中调用？<br>为什么 useEffect 第二个参数是空数组，就相当于 ComponentDidMount ，只会执行一次？<br>React Hooks 分为内置的和自定义的两种类型，内置的 hooks 有以下几个：</p>\n\n        <h3 id=\"Basic-Hooks\">\n            <a href='#Basic-Hooks' class='header-anchor'>#</a>\n            <span>Basic Hooks</span>\n        </h3>\n    <p>useState<br>useEffect<br>useContext</p>\n\n        <h3 id=\"Additional-HooksuseReducer\">\n            <a href='#Additional-HooksuseReducer' class='header-anchor'>#</a>\n            <span>Additional HooksuseReducer</span>\n        </h3>\n    <p>useCallback<br>useMemo<br>useRef<br>useImperativeHandle<br>useLayoutEffect<br>useDebugValue</p>\n\n        <h3 id=\"1.useState\">\n            <a href='#1.useState' class='header-anchor'>#</a>\n            <span>1.useState</span>\n        </h3>\n    <p>const [count,setCount] = useState(0);<br>setCount(),可直接输入要设置的值，也可以传入带参数函数，参数为上一次count值，经过计算处理返回。</p>\n<pre class=\"prettyprint\"><code>  setCount(previous=&amp;gt;{\n    return revious+10\n  })</code></pre><p>注意： useState 的参数可以是基本类型，也可以是对象类型，在更新对象类型时，切记要合并旧的状态，否则旧的状态会丢失</p>\n<pre class=\"prettyprint\"><code>setCount({\n  ...params,\n  countone: 200\n})</code></pre>\n        <h3 id=\"2.useEffect/useLayoutEffect\">\n            <a href='#2.useEffect/useLayoutEffect' class='header-anchor'>#</a>\n            <span>2.useEffect/useLayoutEffect</span>\n        </h3>\n    <p>useEffect是ReactHooks的核心,可取代componentDidMount、componentDidUpdate、componentWillUnmount三个周期。<br>useEffect接受两个参数，其中第二个参数是可选的，不过一般情况下都需要传入第二个参数。</p>\n<pre class=\"prettyprint\"><code>useEffect(()=&amp;gt;{\n\n    return ()=&amp;gt;{}\n},[])</code></pre><p>第一个参数为一个函数，为必传参数，当组件数次渲染或者其依赖的状态改变时会执行，该函数的返回值是可选的，可以不写，如果要写的话必须是一个函数，用于清除上一个状态。</p>\n<p>第二个参数为可选参数，是一个数组。数组中可以传入状态值（通过useState产生的值），当状态值改变的时候首先会执行return函数（即第一个参数中函数的返回值函数），用于清理上一个状态，然后useEffect中的函数就会再次执行。</p>\n<p>***如果不传入第二个参数，代表组件中任何状态的改变，effect都会执行一次，这通常不是我们想要的行为。</p>\n<p>***如果第二个参数传递一个空数组，代表efffect只会执行一次，相当于componentDidmount,return函数也只会在组件卸载的时候执行一次，相当于componentWillUnmount。</p>\n<p>***如果第二个参数数组中有一个或者多个状态值，那么只要有任意一个状态值发生变化，该effect都会再次执行。相当于componentDidUpdate。</p>\n<p>***useEffect是在组件状态改变之后，并且在组件layout和paint之后，也就是说组件出现在页面后再进行调用，useLayoutEffect是在组件状态改变后，但是在组件layout和paint之前，也就是在组件出现在页面之前进行调用。</p>\n<p>***useEffect是异步的，useLayoutEffect是同步的。useEffect不会堵塞主线程渲染。</p>\n\n        <h3 id=\"3.useRef\">\n            <a href='#3.useRef' class='header-anchor'>#</a>\n            <span>3.useRef</span>\n        </h3>\n    <pre class=\"prettyprint\"><code>function xxx(){\n  const inputRef = useRef(null);\n  useEffect(()=&amp;gt;{\n      inputRef.current.value = &#039;hello&#039;\n  },[])\n  return (\n      &amp;lt;input type=&quot;text&quot; ref={inputRef} /&amp;gt;\n  )\n}</code></pre><p>useRef 接收一个初始值，返回一个可变的ref对象，ref.current指向初始化的值。它可以指向别的值。<br>由于是函数组件，this不再指向这个组件，所以要达到class组件中实例变量的效果，可以通过useRef来实现。<br>如果你的 effect 返回一个函数，React 将会在执行清除操作时调用它：<br>为什么 effect 的清除阶段在每次重新渲染时都会执行，而不是只在卸载组件的时候执行一次。让我们看一个实际的例子，看看为什么这个设计可以帮助我们创建 bug 更少的组件。</p>\n\n        <h3 id=\"4.useContext\">\n            <a href='#4.useContext' class='header-anchor'>#</a>\n            <span>4.useContext</span>\n        </h3>\n    <p>useContext的参数必须是context本身；<br>设置context , const ThemContext = React.createContext(themes.light);<br>const value = useContext(MyContext);<br>因为没有static的限制，同一个组件中可以使用多个useContext。也就是说，可以使用多个上层组件传递来的数据。</p>\n\n        <h3 id=\"5.useReducer\">\n            <a href='#5.useReducer' class='header-anchor'>#</a>\n            <span>5.useReducer</span>\n        </h3>\n    <p>提到reducer，首先想到的应该是redux中的reducer。useReducer这个hook与redux中的reducer有所相似又有所不同。可以查看demo中的useReducer。<br>const [state, dispatch] = useReducer(reducer,initialState);<br>要预先写好reducer。<br>dipatch({type:&#39;ADD&#39;});<br>与redux中的reducer有所不同的是，useReducer中的reducer是独立的。如果有多个组件使用到了同一个reducer，那么它们之间的状态是独立的。相较于redux的全局共享状态，它还依赖于react-redux提供的Provider组件。<br>所以是不是突然想到了第四点中的Context，它提供了Provider。如果能配合useReducer，就可以实现全局状态共享了？确实如此！</p>\n\n        <h3 id=\"6.useImperativeHandle\">\n            <a href='#6.useImperativeHandle' class='header-anchor'>#</a>\n            <span>6.useImperativeHandle</span>\n        </h3>\n    <p>useImperativeHandle这个hook是ref的另一种写法。现在通过这个hook可以在子组件中暴露一些API供父组件调用。而父组件是不能直接操作子组件的dom元素的。</p>\n\n        <h3 id=\"7.useCallback\">\n            <a href='#7.useCallback' class='header-anchor'>#</a>\n            <span>7.useCallback</span>\n        </h3>\n    <p>父组件通过props传给子组件一个函数，这个函数用到父组件中的state,如果state改变的时候， memo子组件不会检测到属性的变化，useCallback就是为了解决这一问题，它缓存了一个函数，并接受一系列依赖项，返回一个函数，如果依赖项变化，函数变化。</p>\n<pre class=\"prettyprint\"><code>const handleChange =useCallback (()=&amp;gt;{\n        setResult(count + 1);  //count为父组件的一个state\n},[count])\n//子组件\n&amp;lt;Children  onChange={handleChange} /&amp;gt;</code></pre>\n        <h3 id=\"8.useMemo\">\n            <a href='#8.useMemo' class='header-anchor'>#</a>\n            <span>8.useMemo</span>\n        </h3>\n    <p>useMomo用来缓存一个复杂的计算值，useCallback(fn,deps)等价于useMomo(()=&gt;fn,deps)。如果通过一个输入得到一个值需要经过复杂的计算，那么下次同样的输入再进行一遍同样复杂的计算是没有必要的。这就是useMemo的意义。<br>const result = useMemo(()=&gt;computedExpensiveValue(40),[count]);<br>const result = computedExpensiveValue(40);<br>重新计算result的时候，如果count值没变，就直接从缓存里面读取，避免性能消耗。</p>\n<p>9.useDebugValue</p>\n<p>通常来说你不需要它。它只会存在于自定义的hooks中用来标志一个自定义的hooks。当在chrome中打开react扩展时候，如果一个组件使用到了自定义的hooks，并且该hooks使用到了useDebugValue，那么该组件下方会显示useDebugValue传入的参数。</p>\n<pre class=\"prettyprint\"><code>  function useUserInfo() {\n    // ...\n    useDebugValue(&#039;use-user-info&#039;);\n    return userInfo;\n  }\n</code></pre>"},{"context":[{"title":"大前端","link":"javascript:void(0)"},{"title":"vue","link":"javascript:void(0)"},{"title":"vue工程","link":"/front/vue/project.html"}],"content":"\n        <h1 id=\"vue工程\">\n            <a href='#vue工程' class='header-anchor'>#</a>\n            <span>vue工程</span>\n        </h1>\n    "},{"context":[{"title":"大前端","link":"javascript:void(0)"},{"title":"vue","link":"javascript:void(0)"},{"title":"vue基础语法","link":"/front/vue/vuebase.html"}],"content":"\n        <h3 id=\"vue语法\">\n            <a href='#vue语法' class='header-anchor'>#</a>\n            <span>vue语法</span>\n        </h3>\n    <p>#模板中显示数据<br>{{}}，v-text=&quot;&quot;,v-html=&quot;字符串中包含标签将作为html解析&quot;</p>\n<p>#绑定事件<br>v-on:click=&quot;handleClick&quot;  @click=&quot;handleClick&quot;</p>\n<p>#属性绑定<br>v-bind:title=&quot;title&quot;  , :title=&quot;&quot;</p>\n<p>#双向数据绑定<br>v-model=&quot;&quot;</p>\n<p>#vue中的计算属性和侦听器</p>\n<pre class=\"prettyprint\"><code>computed:{\n    fullName: function(){\n        return this.firstName+&#039; &#039;+this.lastName;\n    }\n}\nwatch:{\n    fullName:function(){\n        监听fullName,如果fullName发生变化，就做出相应变化；\n    }\n}</code></pre><p>#vue中条件判断和循环</p>\n<pre class=\"prettyprint\"><code>v-if=&quot;ture&quot; ， v-show=&quot;true&quot;\n&amp;lt;li v-for=&quot;item of list&quot;&amp;gt;{{item}}&amp;lt;/li&amp;gt;</code></pre><p>#vue中样式和class的绑定<br>style=&quot;原生的样式&quot;<br>:style=&quot;{一个样式的对象，数据可以来自vue实例中的成员变量}&quot;<br>:class=&quot;{&#39;active&#39;: true}&quot; 绑定单个class,并判断是否生效<br>:class=&quot;[{&#39;active&#39;: true},{&#39;isShow&#39;:true}]&quot;<br>#vue中数据传递<br>1.父组件向子组件传递数据props</p>\n<p>父组件将值绑定到子组件属相上:data= &quot;data&quot;<br>子组件</p>\n<pre class=\"prettyprint\"><code>export default {\n    props: [&#039;logo&#039;]\n}\n使用的时候，直接{{logo}}\n```\n2.子组件向父组件传值\n```\n//子组件\n&amp;lt;input @change=&quot;setUser&quot; /&amp;gt;\ndata(){\n    return {\n        username:&#039;&#039;\n    }\n},\nmethods:{\n    setUser: function(){\n        this.$emit(&#039;transferUser&#039;,this.username);\n    }\n}\n//父组件\n&amp;lt;子组件 @transferUser=&quot;getUser&quot;&amp;gt;&amp;lt;/子组件&amp;gt;\nmethods:{\n    getUser(username){\n        this.user=username\n    }\n}\n```\n\n\n\n\n### Vue-cli\nvue工程的脚手架工具\n#全局安装vue-cli\nnpm install -g @vue/cli  @vue/cli-service-global\\\n\n#创建基于webpack模板的新项目\nvue create todolist\n\n#到应用目录下启动项目\nnpm run serve\n\n### 集成element-ui组件库\n\n#安装组件库\ncnpm install -S element-ui\n\n#在main.js中引入，全局可用\nimport ElementUI from &#039;element-ui&#039;\nimport  &#039;element-ui/lib/theme-chalk/index.css&#039;\nVue.use(ElementUI);\n\n\n### vue-router\n\nvue官方路由解决方案\n\n#组件标签\n```\n&amp;lt;div&amp;gt;\n    &amp;lt;router-link to=&quot;/foo&quot;&amp;gt;&amp;lt;/router-link&amp;gt;\n    //匹配到的组件将渲染到这里\n    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;\n&amp;lt;/div&amp;gt;\n```\n#定义路由\n```\nconst routes = [\n    {path:&#039;/foo&#039;,component: Foo},\n    {path:&#039;bar&#039;,component: Bar}\n]\n```\n\n#创建router实例\n```\nconst router = new VueRouter({\n    routes\n})\n```\n#创建和挂载根实例\n```\nconst app = new Vue({\n    router\n}).$mount(&quot;#app&quot;);\n```\n#动态路由传参\n```\nroutes: [\n    {path: &#039;/user/:id&#039;,component: User}\n]\n```\n\n#监测路由变化\n```\nwatch: {\n    &#039;$route&#039;(to,from){\n        //对路由变化做出回应\n    }\n}\n\n```\n#使用路由的一些方法\n\n//获取参数\nthis.$route.params.username;\n//后退\nthis.$router.go(-1);\n//跳转到新的路由\nthis.$router.push(&quot;/&quot;);\nthis.$router 和 router 使用起来完全一样。我们使用 this.$router 的原因是我们并不想在每个独立需要封装路由的组件中都导入路由\n\n#2.2中引入了导航守卫beforeRouteUpdate\n```\nconst User = {\n    template: &#039;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&#039;,\n    beforeRouterUpdate(to,from,next){\n        //执行响应操作，不要忘记回调next();\n    }\n}\n```\n#匹配404\n将这个路由匹配放到最后面\n```\n{\n    path: &#039;*&#039;,//会匹配所有路径\n    component: 404\n}\n```\n当使用通配符时，$route.params内会自动添加一个名为 pathMatch 参数，它包含了URL通过通配符匹配到的东西\nthis.$route.params.pathMatch;\n\n#嵌套路由\n```\nconst User = {\n  template: `\n    &amp;lt;div class=&quot;user&quot;&amp;gt;\n    &amp;lt;h2&amp;gt;User {{ $route.params.id }}&amp;lt;/h2&amp;gt;\n    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;\n    &amp;lt;/div&amp;gt;`\n}\nconst router = new VueRouter({\n  routes: [\n    {\n      path: &#039;/user/:id&#039;, component: User,\n      children: [\n        {\n          // 当 /user/:id/profile 匹配成功，\n          // UserProfile 会被渲染在 User 的 &amp;lt;router-view&amp;gt; 中\n          path: &#039;profile&#039;,\n          component: UserProfile\n        },\n        {\n          // 当 /user/:id/posts 匹配成功\n          // UserPosts 会被渲染在 User 的 &amp;lt;router-view&amp;gt; 中\n          path: &#039;posts&#039;,\n          component: UserPosts\n        }\n      ]\n    }\n  ]\n})\n```\n基于上面的配置，当你访问 /user/foo 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由：\n\n```\nconst router = new VueRouter({\n  routes: [\n    {\n      path: &#039;/user/:id&#039;, component: User,\n      children: [\n        // 当 /user/:id 匹配成功，\n        // UserHome 会被渲染在 User 的 &amp;lt;router-view&amp;gt; 中\n        { path: &#039;&#039;, component: UserHome },\n\n        // ...其他子路由\n      ]\n    }\n  ]\n})\n```\n\n#命名路由\n```\nconst router = new VueRouter({\n    routes:[\n        {\n            path:&#039;/user/:userId&#039;,\n            name:&#039;user&#039;,\n            component: User\n         }\n    ]\n})\n```\n使用时\n```\n&amp;lt;router-link to=&quot;{name:&#039;user&#039;,params:{userId:123}}&quot;&amp;gt;user&amp;lt;/router-link&amp;gt;\nrouter.push({name:&#039;user&#039;,params:{userId:123}});\n```\n#命名视图\n同一个url可以在一个页面上显示多个视图，只要对应好视图名字，未命名的视图则是default\n```\n&amp;lt;div&amp;gt;\n    &amp;lt;router-view class=&quot;view one&quot;&amp;gt;&amp;lt;/router-view&amp;gt;\n    &amp;lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&amp;gt;&amp;lt;/router-view&amp;gt;\n    &amp;lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&amp;gt;&amp;lt;/router-view&amp;gt;\n&amp;lt;/div&amp;gt;\nconst router = new VueRouter({\n  routes: [\n    {\n      path: &#039;/&#039;,\n      components: {\n        default: Foo,\n        a: Bar,\n        b: Baz\n      }\n    }\n  ]\n})\n\n```\n#重定向和别名\n```\nconst router = new VueRouter({\n    routes:[\n        {path:&#039;/a&#039;,redirect:&#039;/b&#039;}  \n        或着 {path:&#039;&#039;,redirect:{name:&#039;foo&#039;}}\n        或者 {path:&#039;/a&#039;,redirect: to=&amp;gt;{\n            //方法接收目标路由作为参数\n            //return 重定向字符串路径或者路径对象\n       }}\n    ]\n})\n\n```\n#别名\n给‘/a’匹配别名‘/b’，则访问‘/b’和访问‘/a’是一样的\n```\nconst router = new VueRouter({\n    routes:[\n        {path: &#039;/a&#039;,component: A, alias: &#039;/b&#039;}\n    ]\n})\n//alias 别名\n```\n#路由组件传参\n通过props将组件和路由解耦\n如果 props 被设置为 true，route.params 将会被设置为组件属性\n```\nconst User = {\n  props: [&#039;id&#039;],\n  template: &#039;&amp;lt;div&amp;gt;User {{ id }}&amp;lt;/div&amp;gt;&#039;\n}\nconst router = new VueRouter({\n  routes: [\n    { path: &#039;/user/:id&#039;, component: User, props: true },\n\n    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：\n    {\n      path: &#039;/user/:id&#039;,\n      components: { default: User, sidebar: Sidebar },\n      props: { default: true, sidebar: false }\n    }\n  ]\n})\n```\n基本都是通过props传递\n\nvue-router默认使用hash路由，不需要后端支持，可用浏览器直接打开，\nhistory路由需要后端环境支持\n使用history路由，后端nginx支持\nnginx\n```\nlocation / {\n  try_files $uri $uri/ /index.html;\n}\n```</code></pre>"},{"context":[{"title":"移动端","link":"javascript:void(0)"},{"title":"react-native","link":"/mobile/reactnative.html"}],"content":"\n        <h3 id=\"react-navigation\">\n            <a href='#react-navigation' class='header-anchor'>#</a>\n            <span>react navigation</span>\n        </h3>\n    <p>创建一个stackNavigator<br>const Stack = createStackNavigator();</p>\n<pre class=\"prettyprint\"><code>&amp;lt;Stack.Navigator initialRouteName=&quot;Home&quot;&amp;gt;\n  &amp;lt;Stack.Screen name=&quot;Home&quot; component={HomeScreen} options={{title:&#039;Over view&#039;}} /&amp;gt;\n  &amp;lt;Stack.Screen name=&quot;Details&quot; component={DetailsScreen} /&amp;gt;\n&amp;lt;/Stack.Navigator&amp;gt;</code></pre><p>屏幕之间跳转 navigate</p>\n<pre class=\"prettyprint\"><code>&amp;lt;View style={{ flex: 1, alignItems: &#039;center&#039;, justifyContent: &#039;center&#039; }}&amp;gt;\n  &amp;lt;Text&amp;gt;Home Screen&amp;lt;/Text&amp;gt;\n  &amp;lt;Button\n    title=&quot;Go to Details&quot;\n    onPress={() =&amp;gt; navigation.navigate(&#039;Details&#039;)}\n  /&amp;gt;\n&amp;lt;/View&amp;gt;\n或者\n&amp;lt;Button\n  title=&quot;Go to Details... again&quot;\n  onPress={() =&amp;gt; navigation.push(&#039;Details&#039;)} //Details是Screen组件的name 属性\n/&amp;gt;\n</code></pre><p>返回<br>当可以从活动屏幕返回时，堆栈导航器提供的标题将自动包含一个后退按钮（如果导航堆栈中只有一个屏幕，则无法返回任何内容，因此没有返回键）。</p>\n<pre class=\"prettyprint\"><code>&amp;lt;Button title=&quot;Go back&quot; onPress={() =&amp;gt; navigation.goBack()} /&amp;gt;</code></pre><p>返回到第一个屏幕</p>\n<pre class=\"prettyprint\"><code>&amp;lt;Button\n  title=&quot;Go back to first screen in stack&quot;\n  onPress={() =&amp;gt; navigation.popToTop()}\n/&amp;gt;</code></pre>\n        <h3 id=\"路由间的参数传递\">\n            <a href='#路由间的参数传递' class='header-anchor'>#</a>\n            <span>路由间的参数传递</span>\n        </h3>\n    <p>这有两部分：</p>\n<p>1.通过将参数放入对象作为navigation.navigate函数的第二个参数，将参数传递给路线：navigation.navigate(&#39;RouteName&#39;, {  params go here  })</p>\n<p>2.阅读屏幕组件中的参数：route.params。</p>\n<pre class=\"prettyprint\"><code>//携带参数\n&amp;lt;Button\n  title=&quot;Go to Details&quot;\n  onPress={() =&amp;gt; {\n    /* 1. Navigate to the Details route with params */\n    navigation.navigate(&#039;Details&#039;, {\n      itemId: 86,\n      otherParam: &#039;anything you want here&#039;,\n    });\n  }}\n/&amp;gt;\n//读取参数\nconst params = route.params;\nconst { itemId,otherParam } = params;\n&amp;lt;Text&amp;gt;itemId: {JSON.stringify(itemId)}&amp;lt;/Text&amp;gt;\n&amp;lt;Text&amp;gt;otherParam: {JSON.stringify(otherParam)}&amp;lt;/Text&amp;gt;\n//更新屏幕参数\nnavigation.setParams()\n//若未指定参数则使用默认参数\n&amp;lt;Stack.Screen\n  name=&quot;Details&quot;\n  component={DetailsScreen}\n  initialParams={{ itemId: 42 }}\n/&amp;gt;</code></pre><p>将参数回传到上一个屏幕<br>参数不仅对将某些数据传递到新屏幕很有用，而且对将数据传递到前一个屏幕也很有用。例如，假设您有一个带有创建帖子按钮的屏幕，并且创建帖子按钮会打开一个新屏幕以创建帖子。创建帖子后，您想要将帖子的数据传递回上一屏幕。</p>\n<pre class=\"prettyprint\"><code>&amp;lt;&amp;gt;\n  &amp;lt;TextInput\n    multiline\n    placeholder=&quot;What&#039;s on your mind?&quot;\n    style={{ height: 200, padding: 10, backgroundColor: &#039;white&#039; }}\n    value={postText}\n    onChangeText={setPostText}\n  /&amp;gt;\n  &amp;lt;Button\n    title=&quot;Done&quot;\n    onPress={() =&amp;gt; {\n      // Pass params back to home screen\n      navigation.navigate(&#039;Home&#039;, { post: postText });\n    }}\n  /&amp;gt;\n&amp;lt;/&amp;gt;\n</code></pre><p>将参数传递给嵌套导航器<br>如果您有嵌套的导航器，则需要以不同的方式传递参数。例如，假设您在Account屏幕内有一个导航器，并且想将参数传递给该导航器内的屏幕Settings。然后，您可以按以下方式传递参数：</p>\n<pre class=\"prettyprint\"><code>navigation.navigate(&#039;Account&#039;, {\n  screen: &#039;Settings&#039;,\n  params: { user: &#039;jane&#039; },\n});</code></pre>\n        <h3 id=\"配置栏标题\">\n            <a href='#配置栏标题' class='header-anchor'>#</a>\n            <span>配置栏标题</span>\n        </h3>\n    <pre class=\"prettyprint\"><code>&amp;lt;Stack.Screen\n  name=&quot;Profile&quot;\n  component={ProfileScreen}\n  options={({ route }) =&amp;gt; ({ title: route.params.name })}\n/&amp;gt;\n\n传递给options函数的参数是具有以下属性的对象：\nnavigation- 屏幕的导航道具。\nroute- 屏幕的路由道具</code></pre><p>更新options和setOptions<br>&lt;Button<br>  title=&quot;Update the title&quot;<br>  onPress={() =&gt; navigation.setOptions({ title: &#39;Updated!&#39; })}<br>/&gt;</p>\n<p>标题样式<br>定制你的头的风格时，有三个关键性能用途：headerStyle，headerTintColor，和headerTitleStyle。</p>\n<p>headerStyle：一种样式对象，该样式对象将应用于View封装标题的。如果设置backgroundColor了它，那将是标题的颜色。<br>headerTintColor：后退按钮和标题都使用此属性作为其颜色。在下面的示例中，我们将颜色设置为白色（#fff），因此后退按钮和标题标题将为白色。<br>headerTitleStyle：如果要自定义标题的fontFamily，fontWeight以及其他Text样式属性，可以使用它来完成。</p>\n<p>options 跨屏幕共享</p>\n<p>将配置上移到prop下的堆栈导航器screenOptions</p>\n<pre class=\"prettyprint\"><code>function StackScreen() {\n  return (\n    &amp;lt;Stack.Navigator\n      screenOptions={{\n        headerStyle: {\n          backgroundColor: &#039;#f4511e&#039;,\n        },\n        headerTintColor: &#039;#fff&#039;,\n        headerTitleStyle: {\n          fontWeight: &#039;bold&#039;,\n        },\n      }}\n    &amp;gt;\n      &amp;lt;Stack.Screen\n        name=&quot;Home&quot;\n        component={HomeScreen}\n        options={{ title: &#039;My home&#039; }}\n      /&amp;gt;\n    &amp;lt;/Stack.Navigator&amp;gt;\n  );\n}</code></pre><p>自定义标题组件headerTitle</p>\n<pre class=\"prettyprint\"><code>function LogoTitle() {\n  return (\n    &amp;lt;Image\n      style={{ width: 50, height: 50 }}\n      source={require(&#039;@expo/snack-static/react-native-logo.png&#039;)}\n    /&amp;gt;\n  );\n}\n\nfunction StackScreen() {\n  return (\n    &amp;lt;Stack.Navigator&amp;gt;\n      &amp;lt;Stack.Screen\n        name=&quot;Home&quot;\n        component={HomeScreen}\n        options={{ headerTitle: props =&amp;gt; &amp;lt;LogoTitle {...props} /&amp;gt; }}\n      /&amp;gt;\n    &amp;lt;/Stack.Navigator&amp;gt;\n  );\n}</code></pre><p>您可能想知道，为什么headerTitle当我们提供组件而不是title像以前那样提供组件？原因是这headerTitle是特定于堆栈导航器的属性，headerTitle默认为Text显示的组件title。</p>\n\n        <h3 id=\"向标题添加按钮\">\n            <a href='#向标题添加按钮' class='header-anchor'>#</a>\n            <span>向标题添加按钮</span>\n        </h3>\n    <p>在标题的右侧添加一个按钮</p>\n<pre class=\"prettyprint\"><code>function StackScreen() {\n  return (\n    &amp;lt;Stack.Navigator&amp;gt;\n      &amp;lt;Stack.Screen\n        name=&quot;Home&quot;\n        component={HomeScreen}\n        options={{\n          headerTitle: props =&amp;gt; &amp;lt;LogoTitle {...props} /&amp;gt;,\n          headerRight: () =&amp;gt; (\n            &amp;lt;Button\n              onPress={() =&amp;gt; alert(&#039;This is a button!&#039;)}\n              title=&quot;Info&quot;\n              color=&quot;#fff&quot;\n            /&amp;gt;\n          ),\n        }}\n      /&amp;gt;\n    &amp;lt;/Stack.Navigator&amp;gt;\n  );\n}</code></pre><p>页头元素说屏幕组件的交互<br>我们需要使用navigation.setOptions定义按钮而不是optionsprop</p>\n<pre class=\"prettyprint\"><code>function StackScreen() {\n  return (\n    &amp;lt;Stack.Navigator&amp;gt;\n      &amp;lt;Stack.Screen\n        name=&quot;Home&quot;\n        component={HomeScreen}\n        options={({ navigation, route }) =&amp;gt; ({\n          headerTitle: props =&amp;gt; &amp;lt;LogoTitle {...props} /&amp;gt;,\n        })}\n      /&amp;gt;\n    &amp;lt;/Stack.Navigator&amp;gt;\n  );\n}\n\nfunction HomeScreen({ navigation }) {\n  const [count, setCount] = React.useState(0);\n\n  React.useLayoutEffect(() =&amp;gt; {\n    navigation.setOptions({\n      headerRight: () =&amp;gt; (\n        &amp;lt;Button onPress={() =&amp;gt; setCount(c =&amp;gt; c + 1)} title=&quot;Update count&quot; /&amp;gt;\n      ),\n    });\n  }, [navigation, setCount]);\n\n  return &amp;lt;Text&amp;gt;Count: {count}&amp;lt;/Text&amp;gt;;\n}</code></pre><p>自定义后退按钮<br>createStackNavigator提供后退按钮特定于平台的默认设置。在iOS上，按钮旁边包含一个标签，当标题适合可用空间时，该标签会显示前一个屏幕的标题，否则显示“返回”。</p>\n<p>您可以使用headerBackTitle和headerTruncatedBackTitle，要自定义后退按钮图像，可以使用headerBackImage。</p>\n\n        <h3 id=\"嵌套导航\">\n            <a href='#嵌套导航' class='header-anchor'>#</a>\n            <span>嵌套导航</span>\n        </h3>\n    <p>嵌套导航意味着在另一个导航器的屏幕内渲染一个导航器</p>\n<pre class=\"prettyprint\"><code>function Home() {\n  return (\n    &amp;lt;Tab.Navigator&amp;gt;\n      &amp;lt;Tab.Screen name=&quot;Feed&quot; component={Feed} /&amp;gt;\n      &amp;lt;Tab.Screen name=&quot;Messages&quot; component={Messages} /&amp;gt;\n    &amp;lt;/Tab.Navigator&amp;gt;\n  );\n}\n\nfunction App() {\n  return (\n    &amp;lt;NavigationContainer&amp;gt;\n      &amp;lt;Stack.Navigator&amp;gt;\n        &amp;lt;Stack.Screen name=&quot;Home&quot; component={Home} /&amp;gt;\n        &amp;lt;Stack.Screen name=&quot;Profile&quot; component={Profile} /&amp;gt;\n        &amp;lt;Stack.Screen name=&quot;Settings&quot; component={Settings} /&amp;gt;\n      &amp;lt;/Stack.Navigator&amp;gt;\n    &amp;lt;/NavigationContainer&amp;gt;\n  );\n}</code></pre><p>每个导航器都有自己的导航历史记录，当在某个屏幕中调用navigation.goBack()时，会返回当前当前导航器的上一个页面，navigate到某个页面，如果页面不在改子导航内，则父导航将会处理。</p>\n<p>嵌套导航器不接收父项的事件<br>例如，如果您在选项卡导航器中嵌套了一个堆栈导航器，则使用时，堆栈导航器中的屏幕将不会接收父选项卡导航器发出的事件，例如（tabPress）navigation.addListener。要从父级导航器接收事件，可以使用显式侦听父级的事件navigation.dangerouslyGetParent().addListener。</p>\n<p>指定子导航的显示屏幕</p>\n<pre class=\"prettyprint\"><code>复制\nfunction Root() {\n  return (\n    &amp;lt;Stack.Navigator&amp;gt;\n      &amp;lt;Stack.Screen name=&quot;Profile&quot; component={Profile} /&amp;gt;\n      &amp;lt;Stack.Screen name=&quot;Settings&quot; component={Settings} /&amp;gt;\n    &amp;lt;/Stack.Navigator&amp;gt;\n  );\n}\n//指定嵌套导航呈现的页面\nnavigation.navigate(&#039;Root&#039;, { screen: &#039;Settings&#039; });\n//将参数传递给嵌套导航屏幕\nnavigation.navigate(&#039;Root&#039;, {\n  screen: &#039;Settings&#039;,\n  params: { user: &#039;jane&#039; },\n});\n//对于深层嵌套导航，可以这样传递\nnavigation.navigate(&#039;Root&#039;, {\n  screen: &#039;Settings&#039;,\n  params: {\n    screen: &#039;Sound&#039;,\n    params: {\n      screen: &#039;Media&#039;,\n    },\n  },\n});</code></pre>\n        <h3 id=\"导航的生命周期\">\n            <a href='#导航的生命周期' class='header-anchor'>#</a>\n            <span>导航的生命周期</span>\n        </h3>\n    <p>每个导航器的首屏被访问后将会被保留状态，当离开时并不执行componentWillUnmount();</p>\n<p>捕捉导航生命周期状态<br>订阅是否聚焦当前页面</p>\n<pre class=\"prettyprint\"><code>function Profile({ navigation }) {\n  React.useEffect(() =&amp;gt; {\n    const unsubscribe = navigation.addListener(&#039;focus&#039;, () =&amp;gt; {\n      // Screen was focused\n      // Do something\n    });\n\n    return unsubscribe;\n  }, [navigation]);\n\n  return &amp;lt;ProfileContent /&amp;gt;;\n}\n\n\n代替手动添加事件侦听器，我们可以使用useFocusEffect挂钩执行副作用。就像React的useEffect钩子一样，但它与导航生命周期息息相关。\n\n例：\nimport { useFocusEffect } from &#039;@react-navigation/native&#039;;\n\nfunction Profile() {\n  useFocusEffect(\n    React.useCallback(() =&amp;gt; {\n      // Do something when the screen is focused\n\n      return () =&amp;gt; {\n        // Do something when the screen is unfocused\n        // Useful for cleanup functions\n      };\n    }, [])\n  );\n\n  return &amp;lt;ProfileContent /&amp;gt;;\n}\n</code></pre>\n        <h3 id=\"打开全屏模式\">\n            <a href='#打开全屏模式' class='header-anchor'>#</a>\n            <span>打开全屏模式</span>\n        </h3>\n    <p>...</p>\n"},{"context":[{"title":"数据库","link":"javascript:void(0)"},{"title":"mysql","link":"/database/mysql.html"}],"content":"\n        <h1 id=\"mysql\">\n            <a href='#mysql' class='header-anchor'>#</a>\n            <span>mysql</span>\n        </h1>\n    \n        <h3 id=\"原生sql语句\">\n            <a href='#原生sql语句' class='header-anchor'>#</a>\n            <span>原生sql语句</span>\n        </h3>\n    \n        <h3 id=\"对数据库的操作\">\n            <a href='#对数据库的操作' class='header-anchor'>#</a>\n            <span>对数据库的操作</span>\n        </h3>\n    <p>创建一个数据库； create database mydb;<br>查看所有数据库： show databases;<br>创建一个数据库并设置字符编码： create database mydb character set gbk;<br>查看数据库编码： show create database mydb;<br>删除一个数据库： drop database mydb;<br>使用一个数据库： use mydb;<br>查看当前正在操作的库； select database();</p>\n\n        <h3 id=\"对数据表的操作\">\n            <a href='#对数据表的操作' class='header-anchor'>#</a>\n            <span>对数据表的操作</span>\n        </h3>\n    <p>创建数据表；<br>create table 表名（<br>    字段名 类型（长度） 约束，<br>    字段名 类型（长度） 约束，<br>    字段名 类型（长度） 约束，<br>）</p>\n<p>例如: create table user(<br>        uid int(32) primary key auto_increment,<br>        uname varchar(32),<br>        upassword varchar(32)<br>    )</p>\n<p>查看数据表：show tables;</p>\n<p>查看表结构： desc user;</p>\n<p>删除表： drop table user;</p>\n<p>修改表(添加一列)： alter table 表名 add 字段名 类型（长度） 约束;<br>修改列的类型（长度）以及约束： alter table 表名 modify 要修改的字段名 类型（长度） 约束；<br>修改表的列名： alter table 表名 change 旧列名 新列名 类型（长度） 约束；<br>删除表的列： alter table 表名 drop 列名;</p>\n<p>修改表名： rename table 旧表名 to 新表名;<br>修改表的字符集：alter table 表名 character set 编码;</p>\n<p>****数据操作<br>插入数据：<br>insert into 表名（列名1，列名2，列名3...） values(值1，值2，值3...);<br>或者insert into 表名 values(值1，值2，值3...);<br>插入数据时出现中文乱码问题： set names gbk;</p>\n<p>修改数据：<br>update 表名 set 字段名=值，字段名=值，字段名=值...<br>它会将该列的所有记录都更改；<br>update 表名 set 字段名=值，字段名=值，字段名=值...where I条件（字段名=值）；</p>\n<p>删除数据：<br>delete from 表名 where 条件（字段名=值）；<br>删除后主键ID不会重置；<br>delete from 表名;删除表内所有数据；</p>\n<p>查询数据：<br>1,通表查询<br>select * from 表名；<br>查询表内所有数据；<br>select 字段1，字段2 from 表名；<br>查询表内这两个字段；<br>select * from 表名 as 别名：<br>查询表内所有数据使用别名；<br>select 字段 as p from 表名；<br>查询表内某个字段使用别名；<br>select distinct(字段) from 表名；<br>查询出去掉重复（依据该字段）的数据<br>select 字段1,字段2+10 from 表名；<br>查询出的数据将字段2加上10进行显示，数据库中的数据并不加10；<br>2,带条件查询，具体到某一条或者几条数据<br>select * from 表名 where 字段1=haha;<br>查询出字段1=haha的所有数据<br>select * from 表名 where 字段1&gt;100;<br>查询出字段1大于100的所有数据；<br>select * from 表名 where 字段1 like &#39;haha&#39;;<br>查询出字段1中含有字符haha的所有数据；<br>select * from 表名 where id in(1,2,4);<br>查询出id为1，2，4的数据；<br>select * from 表名 where 字段1 like &#39;haha&#39; and id=1;<br>查询出id为1并且字段1中包含字符haha的数据；<br>select * from 表名 where id=1 or id=3;<br>查询出id为1或者3的数据；<br>3,查询排序<br>select * from 表名 order by 字段1 asc;<br>查询出所有数据按照字段1的升序进行排列；<br>select * from 表名 order by 字段1 desc;<br>查询出所有数据按照字段1的降序进行排列；<br>select * from 表名 where 字段1 like &quot;haha&quot; order by 字段2 asc;<br>查询出字段1中包含字符&quot;haha&quot;的所有数据并按照字段2按照升序进行排列；</p>\n<p>聚合函数：<br>select sum(字段1) from 表名；<br>获取所有数据字段1的总和；<br>select avg(字段1) from 表名；<br>获取所有数据字段1的平均；<br>select count(*) from 表名；<br>获取所有数据条数；</p>\n<p>分组操作；<br>添加分类id字段 alter table 表名 add cid varchar(32);<br>初始化cid字段 update 表名 set cid=&quot;1&quot;;<br>按条件设置分类字段cid:  update 表名 set cid=&quot;2&quot; where id in(3,4,5);<br>select cid,count(*) from 表名 group by cid;<br>按照cid分组，并统计组内商品的个数；</p>\n<p>4.6 查询总结<br>select  一般在的后面的内容都是要查询的字段<br>from  要查询到表<br>where<br>group by<br>having  分组后带有条件只能使用having<br>order by 它必须放到最后面</p>\n"},{"context":[{"title":"java","link":"javascript:void(0)"},{"title":"mybatis","link":"/java/mybatis.html"}],"content":"\n        <h3 id=\"mybatis\">\n            <a href='#mybatis' class='header-anchor'>#</a>\n            <span>mybatis</span>\n        </h3>\n    <p>###springboot中注解方式使用mybatis</p>\n<p>mybatis起步依赖</p>\n<pre class=\"prettyprint\"><code>&amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;\n    &amp;lt;version&amp;gt;2.1.2&amp;lt;/version&amp;gt;\n&amp;lt;/dependency&amp;gt;</code></pre><p>mysql起步依赖</p>\n<pre class=\"prettyprint\"><code>&amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;\n&amp;lt;/dependency&amp;gt;\n&amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;\n&amp;lt;/dependency&amp;gt;</code></pre><p>application.yml配置</p>\n<pre class=\"prettyprint\"><code>spring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    username: root\n    password: irlen\n    url: jdbc:mysql://10.0.0.99:3306/sell?characterEncoding=utf-8&amp;useSSL=false\n  jpa:\n    show-sql: true</code></pre><p>启动类添加@MapperScan</p>\n<pre class=\"prettyprint\"><code>@MapperScan(basePackages=&quot;mapper包的位置&quot;)</code></pre><p>编写实体类（省略）和mapper</p>\n<pre class=\"prettyprint\"><code>@Mapper\npublic interface UserMapper {\n  @Insert(&quot;insert into user (user_id,user_name,password,role_id) values(&quot; +\n          &quot;#{userId,jdbcType=VARCHAR},&quot; +\n          &quot;#{userName,jdbcType=VARCHAR},&quot; +\n          &quot;#{password,jdbcType=VARCHAR},&quot; +\n          &quot;#{roleId,jdbcType=INTEGER}&quot; +\n          &quot;)&quot;)\n   int saveUser(User user);\n\n  @Select(&quot;select * from user&quot;)\n  @Results({\n          @Result(column=&quot;user_id&quot;, property=&quot;userId&quot;),\n          @Result(column=&quot;user_name&quot;,property=&quot;userName&quot;),\n          @Result(column=&quot;password&quot;,property=&quot;password&quot;),\n          @Result(column=&quot;role_id&quot;,property = &quot;roleId&quot;)\n\n  })\n  List&amp;lt;User&amp;gt; findAll();\n\n  /**\n   * 根据字段更新\n   * @param roleId\n   * @param userName\n   * @return\n   */\n  @Update(&quot;update user set role_id=#{roleId} where user_name=#{userName}&quot;)\n  int updateUser(@Param(&quot;roleId&quot;) Integer roleId,@Param(&quot;userName&quot;) String userName);\n\n  /**\n   * 根据对象来更新\n   * @param user\n   * @return\n   */\n  @Update(&quot;update user set role_id=#{roleId} where user_name=#{userName}&quot;)\n  int updateUserByObject(User user);\n\n  @Delete(&quot;delete from user where user_name=#{userName}&quot;)\n  int deleteUser(String userName);\n}</code></pre><p>最后可以像springDataJPA一样分层<br>mapper-&gt;dao-&gt;service</p>\n"},{"context":[{"title":"java","link":"javascript:void(0)"},{"title":"SpringBoot","link":"/java/springboot.html"}],"content":"\n        <h3 id=\"spring优缺点\">\n            <a href='#spring优缺点' class='header-anchor'>#</a>\n            <span>spring优缺点</span>\n        </h3>\n    <p>优点: 轻量化实现EJB。<br>缺点：配置太繁琐<br>SpringBoot简化了繁琐的配置，使开发的精力集中于业务逻辑代码的编写。<br>SpringBoot不是对Spring功能的增强，而是提供了一个快速使用Spring的方式。</p>\n\n        <h3 id=\"SpringBoot环境搭建\">\n            <a href='#SpringBoot环境搭建' class='header-anchor'>#</a>\n            <span>SpringBoot环境搭建</span>\n        </h3>\n    <p>创建一个module类型的maven工程。</p>\n<p>pom.xml中配置<br>SpringBoot要求，项目要继承SpringBoot的起步依赖spring-boot-starter-parent</p>\n<pre class=\"prettyprint\"><code>  &amp;lt;parent&amp;gt;\n    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;\n    &amp;lt;version&amp;gt;2.0.1.RELEASE&amp;lt;/version&amp;gt;\n  &amp;lt;/parent&amp;gt;</code></pre><p>SpringBoot要继承SpringMVC进行Controller的开发，所以项目要导入web的启动依赖：</p>\n<pre class=\"prettyprint\"><code>&amp;lt;dependencies&amp;gt;\n  &amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;\n  &amp;lt;/dependency&amp;gt;\n&amp;lt;/dependencies&amp;gt;\n</code></pre><p>创建引导类<br>在java中建com.scxgo包，新建文件作为入口文件，例如 MySpringBootApplication类</p>\n<pre class=\"prettyprint\"><code>//此注解声明类是一个SpringBoot的引导类\n@SpringBootApplication\npublic class MySpringBootApplication{\n  //程序入口\n\n  public static void main(String[] args){\n    SpringApplication.run(MySpringBootApplication.class);\n  }\n}</code></pre><p>创建controller<br>创建controller包，建类，类上面加注解@Controller,方法上加@RequestMapping(&quot;/&quot;),@ResponseBody<br>tomcat跑在8080端口<br>IDEA可以自动初始化一个springboot工程<br>创建新工程的时候选择Spring Initializr就可以了。</p>\n\n        <h3 id=\"SpringBoot工程热部署\">\n            <a href='#SpringBoot工程热部署' class='header-anchor'>#</a>\n            <span>SpringBoot工程热部署</span>\n        </h3>\n    <p>pom.xml中需添加依赖<br><dependency><br>  <groupId>org.springframework.boot</groupId><br>  <artifactId>spring-boot-devtools</artifactId><br></dependency><br>注意：热部署失败的原因是 IDEA默认情况下不自动编译，需要对IDEA进行自动编译设置<br>file-settings-Compiler-build project automatically</p>\n<p>shift+ctrl+alt+/,选择Registry-compiler.automake.allow.when.app.running 勾选</p>\n\n        <h3 id=\"SpringBoot配置文件\">\n            <a href='#SpringBoot配置文件' class='header-anchor'>#</a>\n            <span>SpringBoot配置文件</span>\n        </h3>\n    <p>SpringBoot是基于约定的，很多配置都有默认值，需要增加或者覆盖原有配置，可以使用<br>resources文件加下application.properties 或者 application.yml(或者application.yaml)进行配置。（命名规则为application<em>.properties或者application</em>.yml）<br>yml格式</p>\n<pre class=\"prettyprint\"><code>//普通数据的配置\nname: zhangsan  //值前面一定要有个空格\n\n//对象的配置\nperson:\n  name: zhangsan //缩进是自由的，但是要保证每层的缩进是一样的\n  age: 18\n  addr: suizhou\n\n//行内对象配置(用的少)\nperson: {name: zhangsan, age: 18, addr: suizhou}\n\n//配置数组、集合\ncity:\n  - beijing\n  - shanghai\n  - suizhou\n  - shenzhen\n\n//行内数组、集合\ncity: [beijing,shanghai,suizhou,shenzhen]\n\n//配置数组、集合（对象数据）\nstudent:\n  - name: tom\n    age: 18\n    addr: beijing\n  - name: lily\n    age: 25\n    addr: suizhou\n//行内\nstudent: [{name: tom,age: 18,addr:beijing},{name:lily,age:25,addr: suizhou}]</code></pre><p>配置文件与配置类的属性映射<br>有两种方式<br>1.@Value 注解可以将配置文件中的值映射到一个Spring管理的Bean字段上。<br>application.yml中</p>\n<pre class=\"prettyprint\"><code>person:\n  name: zhangsan\n  age: 18\n</code></pre><p>Bean代码如下：</p>\n<pre class=\"prettyprint\"><code>  @Controller\n  public class QuicStartController{\n    @Value(&quot;${person.name}&quot;)\n    private String name;\n    @Value(&quot;${person.age}&quot;)\n    private Integer age;\n  }</code></pre><p>2.@ConfigurationProperties(prefix=&quot;配置文件中key的前缀&quot;)，该注解可以将文件中的配置自动与实体进行映射<br>application.yml中</p>\n<pre class=\"prettyprint\"><code>person:\n  name: zhangsan\n  age: 18</code></pre><p>Bean中</p>\n<pre class=\"prettyprint\"><code>@Controller\n@ConfigurationProperties(prefix=&quot;person&quot;)\npulic class QuikStartController{\n  private String name;\n  private String age;\n  @RequestMapping(&quot;/quik&quot;)\n  @ResponseBody\n  public String quik(){\n    return &quot;my name&quot;+&quot; is &quot;+name;\n  }\n}</code></pre>\n        <h3 id=\"SpringBoot集成\">\n            <a href='#SpringBoot集成' class='header-anchor'>#</a>\n            <span>SpringBoot集成</span>\n        </h3>\n    <p>一.整合mybatis<br>添加mybatis起步依赖</p>\n<pre class=\"prettyprint\"><code>  &amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;artifactId&amp;gt;\n    &amp;lt;version&amp;gt;1.1.1&amp;lt;/version&amp;gt;\n  &amp;lt;/dependency&amp;gt;</code></pre><p>导入数据库坐标（mysql连接驱动）</p>\n<pre class=\"prettyprint\"><code>&amp;lt;dependency&amp;gt;\n  &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;\n  &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;\n&amp;lt;/dependency&amp;gt;</code></pre><p>添加数据库连接信息</p>\n<pre class=\"prettyprint\"><code>spring:\n  datasource:\n    driverClassName: com.mysql.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8\n    username: root\n    password: root</code></pre><p>插入数据(建表sql语句)</p>\n<pre class=\"prettyprint\"><code>//建表语句\n  DROP TABLE IF EXISTS `user`;\n  CREATE TABLE `user`(\n      `id` int(11) NOT NULL AUTO_INCREMENT,\n      `username` varchar(50) DEFAULT NULL,\n      `password` varchar(50)  DEFAUL NULL,\n      `name` varchar(50) DEFAULT NULL,\n      PRIVATE KEY (`id`)\n  ) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;\n\n//插入语句\n  INSERT INTO `user` VALUES (&#039;1&#039;,&#039;zhangsan&#039;,&#039;123&#039;,&#039;张三&#039;);\n  INSERT INTO `user` VALUES (&#039;2&#039;,&#039;lisi&#039;,&#039;123&#039;,&#039;李四&#039;);</code></pre><p>创建实体<br>java内包里见domain包，创建文件User.java建实体类</p>\n<pre class=\"prettyprint\"><code>public class User{\n  private Integer id;\n  private String username;\n  private String password;\n  private String name;\n  //后面为getter，setter方法\n}</code></pre><p>resources文件夹下创建mapper包，里面配置UserMapper.xml</p>\n<pre class=\"prettyprint\"><code>&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;\n&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt;\n\n&amp;lt;mapper namespace=&quot;com.scxgo.mapper.UserMapper&quot;&amp;gt;\n  &amp;lt;select id=&quot;queryUserList&quot; resultType=&quot;user&quot;&amp;gt;\n    select * from user\n  &amp;lt;/select&amp;gt;\n&amp;lt;/mapper&amp;gt;</code></pre><p>java内包中建mapper包，建UserMapper.java文件，写接口</p>\n<pre class=\"prettyprint\"><code>  @Mapper\n  public interface UserMapper{\n    public List&amp;lt;User&amp;gt; queryUserList();\n  }</code></pre><p>在application.yml中配置mybatis信息</p>\n<pre class=\"prettyprint\"><code>mybatis:\n  type-aliases-package: com.scxgo.domain  #pojo别名扫描包\n  mapper-locations: classpath:mapper/*Mapper.xml  #加载mybatis映射文件</code></pre><p>写个controller测试下<br>建包controller</p>\n<pre class=\"prettyprint\"><code>  @Controller\n  public class MybatisController{\n    @Autowired\n    private  UserMapper userMapper;\n    @RequestMapping(&quot;/query&quot;)\n    @ResponseBody\n    public List&amp;lt;User&amp;gt; queryUserList(){\n      List&amp;lt;User&amp;gt; users = userMapper.queryUserList();\n      return users;\n    }\n  }</code></pre>\n        <h3 id=\"集成Junit\">\n            <a href='#集成Junit' class='header-anchor'>#</a>\n            <span>集成Junit</span>\n        </h3>\n    <p>添加Junit起步依赖</p>\n<pre class=\"prettyprint\"><code>  &amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;org.springframwork.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;\n    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;\n  &amp;lt;/dependency&amp;gt;</code></pre><p>编写测试类</p>\n<pre class=\"prettyprint\"><code>@RunWith(SpringRunner.class)\n@SpringBootTest(classes=MyApplication.class) //引导类的字节码\npublic class MyTest{\n  @Test\n  public void test(){\n    ...\n  }\n}</code></pre>\n        <h3 id=\"Spring-Data-JPA集成\">\n            <a href='#Spring-Data-JPA集成' class='header-anchor'>#</a>\n            <span>Spring Data JPA集成</span>\n        </h3>\n    <p>添加起步依赖</p>\n<pre class=\"prettyprint\"><code>&amp;lt;dependency&amp;gt;\n  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;\n&amp;lt;/dependency&amp;gt;</code></pre><p>添加数据库驱动依赖</p>\n<pre class=\"prettyprint\"><code>&amp;lt;dependency&amp;gt;\n  &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;\n  &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;\n&amp;lt;/dependency&amp;gt;</code></pre><p>在application.yml中配置数据库和jpa相关属性</p>\n<pre class=\"prettyprint\"><code>#DB Configuration\nspring:\n  datasource:\n    driverClassName: com.mysql.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8\n    username: root\n    password: root\n#JPA Configuration\n  jpa:\n    datasource: mysql\n    show-sql: true\n    generate-ddl: true\n    hibernate:\n      ddl-auto: update\n      naming_strategy: org.hibernate.cfg.ImprovedNamingStrategy\n</code></pre><p>在domain文件中创建实体类</p>\n<pre class=\"prettyprint\"><code>@Entiry\npublic class User{\n  @Id\n  @GeneratedValue(strategy=GenerationType.IDENTITY)\n  private Long id;\n  private String username;\n  private String password;\n  private name;\n}</code></pre><p>创建repository包，建UserRepository类</p>\n<pre class=\"prettyprint\"><code>//User为实体类名，Long是实体类中id的数据类型\n@Repository\npublic interface UserRepository extends JpaRepository&amp;lt;User,Long&amp;gt;{\n  public List&amp;lt;User&amp;gt; findAll();\n}</code></pre><p>创建实现类UserImpl</p>\n<pre class=\"prettyprint\"><code></code></pre>\n        <h3 id=\"SpringBoot集成Redis\">\n            <a href='#SpringBoot集成Redis' class='header-anchor'>#</a>\n            <span>SpringBoot集成Redis</span>\n        </h3>\n    <p>安装redis服务器并启动<br>添加redis起步依赖</p>\n<pre class=\"prettyprint\"><code>  &amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;\n  &amp;lt;/dependency&amp;gt;</code></pre><p>在application.yml中注入redis连接信息</p>\n<pre class=\"prettyprint\"><code>spring:\n  redis:\n    host: 127.0.0.1\n    port: 6379</code></pre><p>测试redis服务</p>\n<pre class=\"prettyprint\"><code>@RunWith(&quot;SpringRunner&quot;)\n@SpringBootTest(classes=MySpringBootApplication.class)\npublic class RedisTest{\n  @Autowired\n  private RedisTemplate&amp;lt;String,String&amp;gt; redisTemplate;\n  @Autowired\n  private UserRepository userRepository;\n  @Test\n  public void test(){\n    //1.从redis中去获得需要的数据，一般是json字符串格式\n    String userListJson = redisTemplate.boundValueOps(&quot;user.findAll&quot;).get();\n    //2.判断redis中是否存在数据\n    if(null == userListJson){\n      //3.不存在，则从数据库中查询\n      List&amp;lt;User&amp;gt; all = userRepository.findAll();\n      //4.将查出的数据存储到redis缓存中\n      //存之前先要把list转换成string，此时可是有spring自带的jackson来做\n      ObjectMapper objectMapper = new ObjectMapper();\n      userListJson = objectMapper.writeValueAsString(all);\n      redisTemplate.boundValueOps(&quot;user.findAll&quot;).set(userListJson);\n    }\n\n  }\n}\n</code></pre>\n        <h3 id=\"日志使用\">\n            <a href='#日志使用' class='header-anchor'>#</a>\n            <span>日志使用</span>\n        </h3>\n    <p>选择slf4j和Logback框架<br>日志级别 error warn info debug trace<br>默认级别为info，info及其以上级别会触发日志记录<br>在类中使用Log<br>1.非注解方法<br>private final Logger logger =  loggerFactory.getLogger(LoggerTest.class);<br>//LoggerTest为当前使用日志的类<br>logger.info(&#39;输出信息&#39;);</p>\n<p>2.使用注解@Slf4j,需要用到lombok小工具。</p>\n<pre class=\"prettyprint\"><code>//pom.xml中配置\n&amp;lt;dependency&amp;gt;\n  &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;\n  &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;\n&amp;lt;/dependency&amp;gt;\n//类中注解用\nlog.info(&quot;输出信息&quot;);\n//日志中输出变量的方法\nlog.info(&quot;name:&quot;+name);\n或者\nlog.info(&quot;name:{}&quot;,name);</code></pre><p>Logback的配置（application.yml中配置，可区分info和erro,xml可配置定期产生日志）</p>\n<p>logging:<br>  pattern:<br>    console: &quot;%d - %msg%n&quot; //日志格式，输出时间-内容-换行<br>    file: /var/log/tomcat/sell.log //输出日志的文件<br>    level: info  //输出日志级别（info及其级别以上的都会被输出）</p>\n\n        <h3 id=\"表单验证及参数接受\">\n            <a href='#表单验证及参数接受' class='header-anchor'>#</a>\n            <span>表单验证及参数接受</span>\n        </h3>\n    <p>接收参数的几种方式</p>\n<pre class=\"prettyprint\"><code>//此为接收Girl对象的各个属性\npubliuc addGirl(\n  @RequestParam(&#039;age&#039;) Integer age,\n  @RequestParam(&#039;sex&#039;) String sex\n){\n\n}\n//接收一个Girl对象\npublic addGirl(Girl girl){\n\n}</code></pre><p>验证表单中字段合法性<br>实体类中加入限制注解</p>\n<pre class=\"prettyprint\"><code>@Entity\npublic class Girl(){\n  //例如对年龄进行限制\n  @Min(value=18,message=&quot;未成年人禁止入内&quot;)\n  private Integer age;\n}\n//在controller方法中\npublic Girl addGirl(@Valid Girl girl, BindingResult bindingResult){\n    //对girl字段做验证，验证结果在bindingResult中\n    //判断是否严重通过\n    if(bindingResult.hasErrors){\n      System.out.pringln(bindingResult.getFieldError().getDefaultMessage();\n      return null;\n    }\n}</code></pre>\n        <h3 id=\"使用AOP处理请求\">\n            <a href='#使用AOP处理请求' class='header-anchor'>#</a>\n            <span>使用AOP处理请求</span>\n        </h3>\n    <p>pom.xml中添加依赖<br><dependency><br>  <groupId>org.springframework.boot</groupId><br>  <artifactId>spring-boot-starter-aop</artifactId><br></dependency><br>//新建切面类</p>\n<pre class=\"prettyprint\"><code>@Component\n@Aspect\npublic HttpAspect(){\n  pravite final static logger = loggerFactory.getLogger(HttpAspect.class);\n  @Before(&quot;execution(public * com.scxgo.myproject.addGirl(..))&quot;)\n  //两点的意思是无论该方法的参数是什么都适用，就是addGirl所有的重载方法。\n  //@Before是方法执行之前,执行切面中的方法,@After是在方法执行完之后执行切面中方法。\n  public void doBeforMethod(){\n    logger.info(&quot;方法执行前的操作&quot;)\n  }\n}\n\n//excution内容每次都要重复写，可以统一定义\n@Pointcut(&quot;execution(public * com.scxgo.myproject.addGirl(..))&quot;)\npublic void log(){}\n//然后before这样写就行了\n@Before(&quot;log()&quot;)\npublic void doBefore(){}</code></pre>\n        <h3 id=\"统一异常处理\">\n            <a href='#统一异常处理' class='header-anchor'>#</a>\n            <span>统一异常处理</span>\n        </h3>\n    <p>1.定义返回的最外层对象Result</p>\n<pre class=\"prettyprint\"><code>public class Result&amp;lt;T&amp;gt;{\n  private Integer code;\n  private String msg;\n  private T data;\n  //后面为getter,setter方法\n}</code></pre><p>2.定义一个工具类，优化重复代码<br>public class ResultUtil{<br>  //成功的时候调用<br>  public static Result success(Object data){<br>    Result result = new Result();<br>    result.setCode(1);<br>    result.setMessage(&quot;成功&quot;);<br>    result.setData(data);<br>    return result<br>  }<br>  //有时候成功的时候并不需要返回数据，再写一个成功的重载方法<br>  public static Result success(){<br>    return success(null);<br>  }<br>  //失败的时候调用<br>  public static Result error(Integer code, String msg){<br>    Result result = new Result();<br>    result.setMsg(msg);<br>    result.setCode(code);<br>    return result;<br>  }<br>}</p>\n<p>3.新建一个异常捕获类</p>\n<pre class=\"prettyprint\"><code>@controllerAdvice\npublic class ExceptionHandle{\n  @ExceptionHandler(Exception.class)\n  @ResponseBody\n  public Result handle(Exception e){\n    return ResultUtil.error(0,e.getMessage());\n  }\n}\n\n//@ControllerAdvice注解的三个作用\nspringMVC中的功能，springboot中可以直接使用\n//1.全局异常处理\n//2.全局数据绑定\n//3.全局数据预处理\n@ExceptionHandler注解指定处理哪一类异常，这里是所有异常类型。\n@ResponseBody 因为会返回类似json格式的数据到前端，此类上没有RestController注解。\n</code></pre><p>4.定义自己的异常类</p>\n<pre class=\"prettyprint\"><code>public class GirlException extends RunTimeException{\n  private Integer Code;\n  //构造函数\n  public GirlException(Integer code, String message){\n    supper(message);\n    this.code = code;\n  }\n\n  //下面为code的getter,setter方法\n}\n\n//此时异常捕获类可改写成\n@controllerAdvice\npublic class ExceptionHandle{\n  @ExceptionHandler(Exception.class)\n  @ResponseBody\n  public Result handle(Exception e){\n    if(e instanceOf GirlException){\n      GirlException girlException = (GirlException) e;\n      return ResultUtil.error(girlException.getCode(),girlException.getMessage());\n    }\n    return ResultUtil.error(0,e.getMessage());\n  }\n}\n//代码中抛出异常时候可以 throw new GirlException(100,&quot;...出错了&quot;);\n</code></pre><p>5.定义一个枚举类型来管理code和msg的对应关系，可统一维护code和msg</p>\n<pre class=\"prettyprint\"><code>public enum ResultEnum{\n  UNKONUL_ERROR(-1,&quot;未知错误&quot;),\n  SUCCESS(1,&quot;成功&quot;);\n\n\n\n  private Integer code;\n  private String msg;\n  public ResultEnum(Integer code,String msg){\n    this.code = code;\n    this.msg = msg;\n  }\n  //下面为getter方法，枚举不需要setter方法\n\n  此时抛出错误时候直接用枚举代替code和msg,自定义异常类应该改成如下：\n  public class GirlException extends RunTimeException{\n    private Integer Code;\n    //构造函数\n    public GirlException(ResultEnum resultEnum){\n      supper(resultEnum.getMsg());\n      this.code = resultEnum.getCode();\n    }\n\n    //下面为code的getter,setter方法\n  }\n\n</code></pre><p>}</p>\n\n        <h3 id=\"分布式系统下的session\">\n            <a href='#分布式系统下的session' class='header-anchor'>#</a>\n            <span>分布式系统下的session</span>\n        </h3>\n    <p>分布式系统集群是紧密相关的，但是完全不同的概念。<br>分布式是指拥有多个节点，各个几点之间通过消息通信。<br>集群是指同一类节点有多个，担任同一功能，是为了分担任务，减少压力。</p>\n\n        <h3 id=\"mabatis注解使用\">\n            <a href='#mabatis注解使用' class='header-anchor'>#</a>\n            <span>mabatis注解使用</span>\n        </h3>\n    <p>pom.xml引入起步依赖<br><dependency><br>  <groupId>org.mybatis.spring.boot</groupId><br>  <artifactId>mybatis-spring-boot-starter</artifactId><br></dependency><br>新建实体类（省略），新建对应的mapper。</p>\n<pre class=\"prettyprint\"><code>//以新增为例\npublic interface ProductCategoryMapper{\n  @Insert(&quot;insert into product_category (category_name,category_type) values(#{category_name, jdbcType=VARCHAR},#{category_type,jdbcType=INTEGER})&quot;)\n  int insertByMap(Map&amp;lt;String,Object&amp;gt; map);\n  //参数可以用Map也可以用对象，例如ProductCategory\n}\n\n//此时需要在启动类上配置MapperScan,启动时会扫描该mapper\n@MapperScan(basePackages=&quot;com.imooc.dataobject.mapper&quot;)\n\n//使用的时候（单元测试为例）\n@RunWith(SpringRunner.class)\n@SpringBootTest\n@Slf4j\npublic class mybatisTest{\n  @Autowired\n  private ProductCategoryMapper mapper;\n  @Test\n  public void insertTest(){\n    Map&amp;lt;String,Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();\n    map.put(&quot;category_name&quot;,&quot;男生最爱&quot;);  \n    map.put(&quot;category_type&quot;,&quot;101&quot;);  \n    mapper.insertByMap(map);\n  }\n}\n\n//如果需要返回的结果对应成实体类名称，可以这样做\n@Select(&quot;select * from product_category where category_type = #{categoryType}&quot;)\n@Results({\n    @Result(column=&quot;category_type&quot;,property=&quot;categoryType&quot;),\n    @Result(column=&quot;category_name&quot;,property=&quot;categoryName&quot;)\n})\nProductCategory findBycategoryType(Integer categoryType);\n</code></pre>\n        <h3 id=\"websocket\">\n            <a href='#websocket' class='header-anchor'>#</a>\n            <span>websocket</span>\n        </h3>\n    <pre class=\"prettyprint\"><code>pom.xml中引入websocket起步依赖\n&amp;lt;dependency&amp;gt;\n  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n  &amp;lt;artifactId&amp;gt;spring-boot-starter-websocket&amp;lt;/artifactId&amp;gt;\n&amp;lt;/dependency&amp;gt;\n//客户端\n  let websocket = null;\n  if(&#039;Websocket&#039; in window){\n    websocket =  new Websocket(&#039;ws://...&#039;);\n  }else{\n    alert(&quot;该浏览器不支持websocket&quot;);\n  }\n websocket.onopen = function(event){\n   console.log(&quot;建立连接&quot;)\n }\n websocket.onclose = function(event){\n   console.log(&quot;关闭连接&quot;)\n }\n websocket.onmessage = function(evnet){\n   console.log(&quot;收到消息&quot;+event.data)\n }\n websocket.onerror = funciton(){\n   alert(&quot;websocket通信发生错误&quot;)\n }\n window.onbeforeunload = function(){\n   websocket.close();\n   console.log(&quot;窗口关闭，关闭websocket连接&quot;)\n }\n\n //后端\n //写个websocket配置类\n\n @Compoennt\n public class WebsocketConfig{\n   @Bean\n   public ServerEndpointExporter serverEndpointExporter{\n     return new ServerEndpointExporter();\n   }\n }\n //写websocket组件\n @Component\n @ServerEndpoint(&quot;/webSocket&quot;)\n @Slf4j\n public class WebSocket{\n\n   private Session session;\n   private static CopyOnWriteArraySet&amp;lt;WebSocket&amp;gt; webSocketSet = new CopyOnWriteArraySet&amp;lt;&amp;gt;();\n\n   @onopen\n   public void onOpen(Session session){\n     this.session = session;\n     webSocketSet.add(this)\n     log.info(&quot;[websocket消息] 有新的连接,总数：{}&quot;,webSocketSet.size());\n   }\n\n   @OnClose\n   public void onClose(){\n     webSocketSet.remove(this);\n     log.info(&quot;断开，总数{}&quot;,webSocketSet.size());\n   }\n\n   @OnMessage\n   public void onMessage(String message){\n     log.info(&quot;收到客户端发来的消息:{}&quot;,message);\n   }\n\n   public void sendMessage(String message){\n     for(WebSocket webSocket:webSocketSet){\n       log.info(&quot;广播消息，message={}&quot;,message);\n       try{\n         webSocket.session.getBasicRemote().sendText(message);\n       } catch(Exception e){\n         e.printStackTrace();\n       }\n     }\n   }\n}</code></pre><p><code></code></p>\n<pre class=\"prettyprint\"><code></code></pre>"},{"context":[{"title":"java","link":"javascript:void(0)"},{"title":"annotation","link":"/java/annotation.html"}],"content":"\n        <h3 id=\"IOC容器注解\">\n            <a href='#IOC容器注解' class='header-anchor'>#</a>\n            <span>IOC容器注解</span>\n        </h3>\n    <p>@Component<br>  作用<br>    将当前对象放存入Spring容器。<br>  属性<br>    value: 用于指定bean的id,不指定，则默认为当前类名，且首字母小写。<br>  类似@Component注解<br>@Controller<br>@Service<br>@Repository<br>  作用<br>    同Component注解一样，只是对三层代码类的注解</p>\n<p>@Bean<br>  作用<br>    作用在方法上，将方法的返回值作为bean对象放入spring容器。<br>  属性<br>    name: 用于指定bean的id,不写时，默认值为当前方法名称。<br>  细节<br>    当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。查找的方式和Autowired注解的作用是一样的。</p>\n\n        <h3 id=\"配置相关注解\">\n            <a href='#配置相关注解' class='header-anchor'>#</a>\n            <span>配置相关注解</span>\n        </h3>\n    <p>@Configuration<br>  作用<br>    指定当前类是一个配置类</p>\n<p>@Import<br>  作用<br>    将一个类包含到另一个类，通常是配置类（分配置引入到主配置中）<br>  属性<br>    value: 被引入类的字节码<br>@ComponentScan<br>  作用<br>    用于通过注解指定spring在创建容器时要扫描的包。<br>  属性<br>    value: 它和basePackages的作用是一样的，都是用于制动创建容器时要扫描的包。</p>\n<p>@PropertySource(&quot;classpath:config/spring/.jdbcConfig.properties&quot;)<br>  通常配合@Value使用，不指定配置文件的时候，默认是主配置文件（application.properties或者application.yml）<br>  作用<br>    用于指定properties文件的路径。<br>  属性<br>    value: 指定文件的名称和路径<br>    关键字: classpath,表示类路径下</p>\n<p>@ConfigurationProperties(prefix=&quot;spring&quot;)<br>  作用<br>    将application.yml中的字段自动映射到注解类的成员变量<br>  属性<br>    prefix: 配置文件下字段spring对象下的字段作为映射对象</p>\n\n        <h3 id=\"注入数据\">\n            <a href='#注入数据' class='header-anchor'>#</a>\n            <span>注入数据</span>\n        </h3>\n    <p>@Autowired<br>  作用<br>    自动按照类型注入，只要容器中有唯一的一个bean对象类型和注入变量的类型匹配，就可以注入成功。<br>    如果容器没有类型匹配则报错。<br>    如果容器中有多个类型与之匹配，会报错，此时需要用到Qualifier注解。<br>  位置<br>    可以是变量上，也可以是方法上<br>  @Qualifier(value=&quot;bean的id&quot;)  (本意为限定符，修饰词，合格者)<br>  作用<br>    在按照类型注入的基础之上再按照名称注入，它在给类成员注入时不能单独使用（Autowired注解的类型有多个时使用），但是在给方法参数注入时可以单独使用。<br>  属性<br>    value:被注入的bean的id<br>  注：Qualifier在个方法参数注解的时候可以独立使用，value值为bean的id</p>\n<pre class=\"prettyprint\"><code>    public QueryRunner createQueryRunner(@Qualifier(&#039;ds1&#039;) DataSource dataSource){\n      //有两个返回DataSource类型值的方法被@Bean注解了，此时需要通过id来识别到底是用哪个作为参数\n    }\n</code></pre><p>@Resource(name=&quot;bean的id&quot;)<br>  作用<br>    直接按照bean的id注入，可以独立使用（取代Autowired和Qualifier一起使用的情况）。<br>  属性<br>    name: 被注入的bean的id</p>\n<p>  注意：以上三个注入只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现，另外，集合类型的注入只能通过XML来实现。</p>\n<p>@Value<br>  作用<br>    用于注入基本类型和String类型的数据<br>  属性<br>    value: 用于指定数据的值，它可以使用spring的SpEl（el表达式，即${表达式}）</p>\n\n        <h3 id=\"用于改变作用范围的注解\">\n            <a href='#用于改变作用范围的注解' class='header-anchor'>#</a>\n            <span>用于改变作用范围的注解</span>\n        </h3>\n    <p>@Scope<br>  作用<br>    用于指定bean的作用范围。<br>  属性<br>    value: 指定范围的取值，常用值为 singleton prototype,即单例和多例，不写的时候默认为单例。<br>    <code>@Scope(&amp;quot;prototype&amp;quot;)//多实例，IOC容器启动创建的时候，并不会创建对象放在容器在容器当中，当你需要的时候，需要从容器当中取该对象的时候，就会创建。\n    @Scope(&amp;quot;singleton&amp;quot;)//单实例 IOC容器启动的时候就会调用方法创建对象，以后每次获取\n    @Scope(&amp;quot;request&amp;quot;)//同一个请求创建一个实例\n    @Scope(&amp;quot;session&amp;quot;)//同一个session创建一个实例</code></p>\n\n        <h3 id=\"生命周期相关注解\">\n            <a href='#生命周期相关注解' class='header-anchor'>#</a>\n            <span>生命周期相关注解</span>\n        </h3>\n    <p>@PreDestroy<br>  作用<br>    用在方法上，用于指定该方法为销毁方法。<br>@PostConstruct<br>  作用<br>    用在方法上，用于指定该方法为初始化方法。<br>注：多例对象的销毁spring不负责，所以单例对象销毁之前会调用销毁方法</p>\n\n        <h3 id=\"请求类中的注解\">\n            <a href='#请求类中的注解' class='header-anchor'>#</a>\n            <span>请求类中的注解</span>\n        </h3>\n    <p>请求类一般用@Controller或者@RestController注解<br>类中的方法上的注解<br>@RequestMapping(&quot;/quik&quot;)<br>@ResponseBody</p>\n\n        <h3 id=\"测试类中的注解\">\n            <a href='#测试类中的注解' class='header-anchor'>#</a>\n            <span>测试类中的注解</span>\n        </h3>\n    <p>测试类上的注解<br>@RunWith(SpringRunner.class)<br>@SpringBootTest(classes = MySpringBootApplication.class) //引导类的字节码<br>方法上的注解<br>@Test</p>\n<p>###实体类中的注解<br>@Entity  //注解在类上，表示设个类是实体类<br>@DynamicUpdate //注解在类上，更新时间字段在该条数据更新的时候更新为当前时间<br>注解在成员变量上的注解<br>@Id  表明该字段为映射数据表的主键<br>@GeneratedValue(strategy=GenerationType.IDENTITY) //mysql数据库自增字段的策略</p>\n<p>配置lombok<br><dependency><br>  <groupId>org.projectlombok</groupId><br>  <artifactId>lombok</artifactId><br></dependency><br>安装lombok插件。<br>然后在类上使用@Data注解。<br>这样就不用写getter,setter, toString方法了。</p>\n"},{"context":[{"title":"java","link":"javascript:void(0)"},{"title":"常用方法","link":"/java/method.html"}],"content":"\n        <h3 id=\"Optional\">\n            <a href='#Optional' class='header-anchor'>#</a>\n            <span>Optional</span>\n        </h3>\n    <p>java8中引入，解决对象可能有值，也可能为空的冗余判断</p>\n<p>通过静态方法创建</p>\n<pre class=\"prettyprint\"><code>empty()\n  返回一个空的Optional对象\nof()\nofNullable()\n  我们都是通过of和ofNullable方法来为Optional中的value赋值，他们也是有区别的\n    of方法的特点\n      1.当value值为空时，会报NullPointerException异常；\n      2.当value值不为空时，正常构造Optional对象；\n    ofNullable方法特点\n      如果value值为空，会返回empty方法构建的Optional对象（即Optional中value为空的Optional对象），也就是说ofNullable支持空值的创建；      \nget()\n  返回Optional中的value值\n\nisPresent和ifPresent\n  isPresent是判断Optional中的value是否为空，不为空返回true，为空返回false；\n  ifPresent方法是Optional中value不为空的情况下做的一些操作；\n  例如：\n  Optional.ofNullable(user).ifPresent(System.out.println(&quot;不为空&quot;))\n\norElse()、 orElseGet() 和 orElseThrow()\n  都是处理Optional值为空的情况，如果传入value为空，进行操作；\n  orElse和orElse的区别在于，如果value不为空，orElse中的操作仍然要执行，orElseGet则不会。\n  orElseThrow()是在value为空的时候抛出异常；</code></pre>\n        <h3 id=\"合并连个类（拷贝第一个类的同名属性到第二个类）\">\n            <a href='#合并连个类（拷贝第一个类的同名属性到第二个类）' class='header-anchor'>#</a>\n            <span>合并连个类（拷贝第一个类的同名属性到第二个类）</span>\n        </h3>\n    <pre class=\"prettyprint\"><code>BeanUtils.copyProperties(Obj1,Obj2);</code></pre>"},{"context":[{"title":"java","link":"javascript:void(0)"},{"title":"常用api","link":"/java/api.html"}],"content":"\n        <h3 id=\"Scanner类\">\n            <a href='#Scanner类' class='header-anchor'>#</a>\n            <span>Scanner类</span>\n        </h3>\n    <p>一个获取键盘输入到程序中的类；</p>\n<pre class=\"prettyprint\"><code>//创建对象，构造函数必须传入参数，参数为输入来源，System.in为键盘输入;\nScanner  sc = new Scanner(System.in);\n//获取输入的整数\nint num = sc.nextInt();\n//获取输入的字符串\nString num = sc.next();</code></pre>\n        <h3 id=\"Random类\">\n            <a href='#Random类' class='header-anchor'>#</a>\n            <span>Random类</span>\n        </h3>\n    <pre class=\"prettyprint\"><code>Random r = new Random();\n//无参的方法，得到的Int范围内的所有可能数字，有正负两种\nint num =  r.nextInt();\n//有参数的重载方法，参数代表左闭右开区间，例如 int num = r.nextInt(3);代表含义为[0,3),即0,1,2\n\n</code></pre>\n        <h3 id=\"String\">\n            <a href='#String' class='header-anchor'>#</a>\n            <span>String</span>\n        </h3>\n    <p>字符串的比较不应该用“==”,应该使用equals();<br>将字符串变成大小写 s.toUpperCase()， s.toLowerCase();<br>忽略大小写比较 equalsIgnoreCase();<br>判断字符串中是否包含某些字符 hello.contains(&quot;ll&quot;);<br>去除字符串的首尾空白字符,并不改变原来字符串内容，返回新的字符串 s.trim(); //trim 修剪<br>移除字符串首尾空白字符包括类似中文空格字符 s.strip() //strip 扒光，脱光衣服，剥去一层<br>判断是否为空 s.isEmpty()<br>判断是否为空白字符 s.isBlank();<br>按照符号分隔字符串<br> String s = &quot;A,B,C,D&quot;;<br> String[]  ss = s.split(&quot;\\,&quot;);<br> 实际上是,，因为Java中\\是转义字符前导符，所以在字符串中书写\\必须得写成\\才能正确识别，所以正则表达式中的,就表示为\\,的。<br> 反向操作为join<br> String[] arr = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;];<br> String s = String.join(&quot;***&quot;,arr);</p>\n<p> 格式化字符串（java提供了formatted()方法和format()静态方法）<br> String s = &quot;Hi %s, your score is %d!&quot;;<br> System.out.println(s.formatted(&quot;Alice&quot;,80));</p>\n<p> %s : 表示字符串<br> %d : 表示整数<br> %x : 表示十六进制整数<br> %f : 表示浮点数</p>\n<p> 要把任意基本类型或者引用类型转换为字符串，可以使用静态方法valueOf(),这是一个重载方法，编译器会根据参数类型自动选择合适的方法。<br> String.valueOf(123); //&quot;123&quot;<br> String.valueOf(true); //&quot;true&quot;<br> 字符串转换成int类型<br> Integer.parseInt(&quot;123&quot;); //123<br> 转换成boolean类型<br> boolean b = Boolean.parseBoolean(&quot;true&quot;); //true</p>\n<p> 字符數組和字符串的相互轉化<br> char[] cs = &quot;Hello&quot;.toCharArray();<br> String s = new String(cs);</p>\n\n        <h3 id=\"包装类型\">\n            <a href='#包装类型' class='header-anchor'>#</a>\n            <span>包装类型</span>\n        </h3>\n    <p>基本类型： byte, short, int ,long, boolean, float, double, char（java对所有的基本类型都提供了包装类）<br>引用类型： class 和 interface (String,Integer,Boolean等等，都属于包装类)<br>引用类型可赋值为null,表示空，单基本类型不能赋值为null;</p>\n<p>总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！</p>\n\n        <h3 id=\"java中的集合\">\n            <a href='#java中的集合' class='header-anchor'>#</a>\n            <span>java中的集合</span>\n        </h3>\n    <p>数组<br>  String[] ss = new String[10];<br>  数组有两个特点<br>  1。数组初始化之后大小不可变。<br>  2. 数组只能索引顺序存取。</p>\n<p>Collection<br>    Collection是出map之外的其他集合的根接口，java包主要提供了一下三种类型集合。<br>    List: 一种有特定顺序的表集合。<br>    Set: 一种保证没有重复元素的结合。<br>    Map: 一种通用键值查找的映射表结合。<br>Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。<br>List<br>  List接口的实现类为 ArrayList 和 LinkList<br>  add()添加<br>  remove() 删除<br>  get(索引) 获取索引对应的元素<br>  我们要始终坚持使用迭代器Iterator来访问List。<br>  Iterator本身也是一个对象，但它是由List的实例调用iterator()方法的时候创建的。<br>  Iterator对象知道如何遍历一个List，并且不同的List类型，返回的Iterator对象实现也是不同的，但总是具有最高的访问效率。<br>  Iterator对象有两个方法：hasNext()判断是否有下一个元素，next()返回下一个元素。</p>\n<pre class=\"prettyprint\"><code>  例： List&amp;lt;String&amp;gt; list = List.of(&quot;orange&quot;,&quot;apple&quot;,&quot;grape&quot;);\n  for( Iterator&amp;lt;String&amp;gt; lt=list.iterator(); lt.hasNext(); ){\n    String s = lt.next();\n    System.out.println(s);\n  }\n  List转Array\n  List&amp;lt;String&amp;gt; ls= List.of(&quot;orange&quot;,&quot;apple&quot;,&quot;grape&quot;);\n  Object[] ar = ls.toArray();\n  //此方法会丢失类型，通常这样做\n  String[] ar = ls.toArray(new String[3]);\n  //List.of()是一个只读list</code></pre><p>Map<br>  Map&lt;String,Student&gt; mp = new HashMap&lt;&gt;();<br>  mp.put(&quot;xiaoming&quot;,new Student());<br>  map.get(&quot;xiaoming&quot;);<br>  map遍历</p>\n<pre class=\"prettyprint\"><code>  Map&amp;lt;String,Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();\n  map.put(&quot;apple&quot;,123);\n  map.put(&quot;pear&quot;,456);\n  map.put(&quot;banana&quot;,789);\n  for(String key:map.keySet()){\n    Integer value = map.get(key);\n    System.out.println(value);\n  }\n  //或者\n  for(Map.Entry&amp;lt;String,Integer&amp;gt; entry:map.entrySet()){\n    String key = entry.getKey();\n    Integer value = entry.getValue();\n  }\n</code></pre><p> ···</p>\n"},{"context":[{"title":"java","link":"javascript:void(0)"},{"title":"登录验证方式","link":"/java/login.html"}],"content":"\n        <h3 id=\"JWT登录方式\">\n            <a href='#JWT登录方式' class='header-anchor'>#</a>\n            <span>JWT登录方式</span>\n        </h3>\n    <dependency>\n  <groupId>io.jsonwebtoken</groupId>\n  <artifactId>jjwt</artifactId>\n  <version>0.9.1</version>\n</dependency>\n<dependency>\n  <groupId>com.auth0</groupId>\n  <artifactId>java-jwt</artifactId>\n  <version>3.4.0</version>\n</dependency>\n"},{"context":[{"title":"微信小程序","link":"javascript:void(0)"},{"title":"微信小程序","link":"/wechat/wechat.html"}],"content":"\n        <h3 id=\"准备工作\">\n            <a href='#准备工作' class='header-anchor'>#</a>\n            <span>准备工作</span>\n        </h3>\n    <p>1.进入微信公众平台官网<br>  <a href=\"http://mp.weixin.qq.com\">http://mp.weixin.qq.com</a><br>  -注册账号（分为个人和企业，只能注册个人）<br>  -下载微信开发者工具(开发文档-工具-下载)<br>  -登录小程序上号后台获取appid</p>\n<p>给小程序设置苹方字体(只有苹果设备有效果)<br>font-family:&quot;PingFangSC-Thin&quot;;</p>\n<p>2.定义与引用组件<br>定义一个组件，跟page页面是一样的结构。<br>在引用该组件时，要在引用page的json配置文件中配置<br>{<br>  &quot;usingComponents&quot;:{<br>    &quot;icon&quot;:&quot;组件的路径&quot;<br>  }<br>}</p>\n<p>3.数据传递<br>父组件向子组件传递数据是实用properties<br>Component({<br>  properties:{<br>    属性名:{<br>      type: 属性类型（String,Boolean,Number 等）,<br>      value: 默认值,//可选<br>      observer:function(newVal,oldVal,changedPath){<br>        //可选</p>\n<pre class=\"prettyprint\"><code>  }\n}</code></pre><p>  }<br>})<br>组件中复用数据使用behavior<br>结构和组件一样，使用功能Behavior关键词定义<br>Behavior({<br>    properties:{<br>      //主要是将各组件中需要复用的数据放在这里<br>    }<br>})<br>组件中导入behavior组件，在组件中复用的时候加上<br>behaviors:[]</p>\n<p>4.页面生命周期函数<br>onLoad:funciton(){//页面加载,onLoad在onReady之前触发，且每次更新都会触发}<br>onReady:function(){//页面初次渲染完成}<br>onShow:function(){//页面显示}<br>onHide:function(){//页面隐藏}<br>onUnload:function(){//页面卸载}</p>\n<p>5.组件生命周期函数<br>create:function(){//组件实例进入页面节点树的时候执行，注意此时不能调用setData}<br>attached: funciton(){//组件实例进图页面节点树的时候执行,常用}<br>6.请求数据<br>wx.request({<br>    url,<br>    head,<br>    dataType:&quot;返回数据类型&quot;,<br>    method:&quot;GET&quot;,<br>    data:&quot;请求参数&quot;,<br>    success:function(result){},<br>    fail:function(result){},<br>    complete:function(){//接口调用结束后的回调函数，成功或失败都会执行}<br>  })</p>\n<p>7.引入组件库开发<br>npm  init<br>npm i vant-weapp -S --production<br>工具-构建npm<br>右上角详情-本地设置-使用npm模块</p>\n"},{"context":[{"title":"微信小程序","link":"javascript:void(0)"},{"title":"微信授权及支付","link":"/wechat/wxtrade.html"}],"content":"\n        <h3 id=\"微信网页授权\">\n            <a href='#微信网页授权' class='header-anchor'>#</a>\n            <span>微信网页授权</span>\n        </h3>\n    <p>官方文档<br><a href=\"https://mp.weixin.qq.com/wiki\">https://mp.weixin.qq.com/wiki</a></p>\n<p>调试（内网穿透）<br><a href=\"https://netapp.cn\">https://netapp.cn</a></p>\n<p>第三方SDK<br><a href=\"https://github.com/Wechat-Group/weixin-java-tools\">https://github.com/Wechat-Group/weixin-java-tools</a></p>\n<p>微信支付<br><a href=\"https://pay.weixin.qq.com/wiki\">https://pay.weixin.qq.com/wiki</a></p>\n<p>微信公众平台接口测试账号申请<br><a href=\"https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login\">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</a></p>\n<p>微信支付sdk<br>1.在springboot项目中引入maven依赖；</p>\n<pre class=\"prettyprint\"><code>&amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;com.github.binarywang&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;wx-java-pay-spring-boot-starter&amp;lt;/artifactId&amp;gt;\n    &amp;lt;version&amp;gt;${version}&amp;lt;/version&amp;gt;\n&amp;lt;/dependency&amp;gt;</code></pre><p>2.添加配置（application.yml）<br>wx:<br>  pay:<br>    appId:<br>    mchId:<br>    mchKey:<br>    subAppId:<br>    subMchId:<br>    keyPath: </p>\n"},{"context":[{"title":"Bash脚本","link":"javascript:void(0)"},{"title":"简介","link":"/bash/introduce.html"}],"content":"\n        <h3 id=\"Bush简介\">\n            <a href='#Bush简介' class='header-anchor'>#</a>\n            <span>Bush简介</span>\n        </h3>\n    <p>Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应<br>Bash 是目前最常用的 Shell</p>\n<p>下面命令可以查看当前运行的Shell</p>\n<pre class=\"prettyprint\"><code>echo $SHELL</code></pre><p>下面命令可以查看当前的Linux系统安装的所有Shell</p>\n<pre class=\"prettyprint\"><code>cat /etc/shells</code></pre>"},{"context":[{"title":"git","link":"javascript:void(0)"},{"title":"git","link":"/git/git.html"}],"content":"\n        <h3 id=\"一.创建版本库（repository）\">\n            <a href='#一.创建版本库（repository）' class='header-anchor'>#</a>\n            <span>一.创建版本库（repository）</span>\n        </h3>\n    <p>  创建一个空目录，并初始化<br>  mkdir learngit<br>  cd learngit<br>  git init<br>  git init --bare //初始化一个纯版本目录，不带本地仓库</p>\n\n        <h3 id=\"二.把文件添加到版本库\">\n            <a href='#二.把文件添加到版本库' class='header-anchor'>#</a>\n            <span>二.把文件添加到版本库</span>\n        </h3>\n    <p>  建一个文件，并告诉git把文件添加到仓库<br>  touch readme.txt<br>  git add readme.txt  //文件添加到仓库<br>  git commit -m &#39;描述内容&#39; //把文件提交到git仓库</p>\n\n        <h3 id=\"三.时光穿梭机\">\n            <a href='#三.时光穿梭机' class='header-anchor'>#</a>\n            <span>三.时光穿梭机</span>\n        </h3>\n    <p>  1.版本回退<br>    git status //git会告诉我们是否有改动，改动是否提交，但不会告诉我们具体改动的地方<br>    git diff readme.txt //git会告诉你readme.txt文件里面具体被改动的地方<br>    每次修改文件或者文件夹后需要做两个操作，<br>    git add  (文件或者文件夹)<br>    git commit -m &#39;描述&#39;<br>    git log 显示最近到最远的提交日志<br>    回退到某个版本，HEAD表示当前版本，HEAD^表示上一个版本 HEAD~100表示往上数第一百个版本<br>    git reset --hard HEAD^<br>    git reset --hard 190dee23dkd //后面为要回退版本的id,只用写前几位就可以了<br>    如果回退到某个版本，又后悔了想回到之前的版本，这个时候没有id<br>    git reflog //会显示之前每次的命令</p>\n<p>  2.工作区和暂存区以及本地版本库<br>    工作区(Working Directory)<br>    即电脑里能看到的目录，你自己本地编辑的代码文件<br>    工作区里面有个隐藏目录.git，这个不算工作区，而是Git的版本库（repository）<br>    版本库里有个暂存区（stage或者index），还有自动创建的分支master,以及指向分支的指针HEAD<br>    之前把文件往版本库里添加的时候分两步操作<br>    git add 是把文件修改添加到暂存区<br>    git commit 是把暂存区所有内容提交到当前分支<br>    git checkout --readme.txt 丢弃工作区的修改（即回到最近一次git commit或者git add的状态）</p>\n<p>  3.管理修改<br>  删除版本库中的文件<br>  git rm test.txt 并且commit</p>\n\n        <h3 id=\"四.远程仓库\">\n            <a href='#四.远程仓库' class='header-anchor'>#</a>\n            <span>四.远程仓库</span>\n        </h3>\n    <p>  1.添加远程库并推送本地仓库到远程仓库<br>    linux设置ssh秘钥<br>    ssh-keygen -t rsa -C &#39;wangyangruoshi@163.com&#39;<br>    将公钥添加到github，github中新建仓库(new repository)<br>    在本地关联远程仓库<br>    git remote add origin <a href=\"mailto:git@github.com\">git@github.com</a>:irlen/learngit.git<br>    将本地仓库的内容推送到远程仓库<br>    git push -u origin master  (第一次推送加上-u，不仅推送还会关联，之后推送拉取都可以简化命令)<br>  2.从远程库克隆<br>    git clone <a href=\"mailto:git@github.com\">git@github.com</a>:irlen/gitskills.git</p>\n\n        <h3 id=\"五.分支管理\">\n            <a href='#五.分支管理' class='header-anchor'>#</a>\n            <span>五.分支管理</span>\n        </h3>\n    <p>  1.创建与合并分支<br>    创建dev分支，并切换到dev分支<br>    git checkout -b dev (-b参数表示创建并切换,相当于git branch dev 和 git checkout dev两个命令)<br>    git branch 查看当前分支<br>    将dev分支合并到master分支<br>    git checkout master<br>    git merge dev<br>    删除dev分支<br>    git branch -d dev<br>  2.解决冲突<br>    两个分支改了同一个地方合并的时候发生冲突<br>    git status 可查看冲突的是哪个文件<br>    git会用《《《《《 ==========》》》》》》表示出不同，改统一后再git add 和 git commit<br>    git log --graph 可以看到分支合并图<br>  3.分支管理策略<br>    合并分支时，git会用Fast forward模式，这种模式删除分支后会丢掉分支信息。<br>    禁用Fast forward模式，从分支历史就可以看出分支信息<br>    git merge --no-ff -m &#39;merge with no-off&#39; dev<br>    实际开发中，master分支应该是相当稳定，只用来发布新版本，平时不能在上面干活，干活都在dev分支上，每个人都有自己的dev分支，时不时的往dev分支上合并<br>  4.暂存和删除未合并分支<br>    当你在dev分支上开发到一半，突然要在maser上新建一个bug分支来改bug,这个时候dev分支因为不能提交，需要暂存起来<br>    git stash 暂存现有分支为提交的内容<br>    git stash list 列出暂存的工作现场<br>    git stash pop 恢复工作现场并删除暂存 (相当于git stash apply 和 git stash drop 两个命令的结果)<br>    当你开发一个新功能分支，然后上面告诉你这个并能不要了，那你需要将这个功能分支删除(要用大写-D 参数)<br>    git branch -D branchName<br>  5.多人协作<br>    git remote -v 显示远程仓库的详细细信息<br>    推送分支,要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上<br>    git push origin master<br>    并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？<br>      master分支是主分支，因此要时刻与远程同步；<br>      dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；<br>      bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；<br>      feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。<br>    抓取分支<br>      当从远程库克隆时，默认只能看到本地的master分支，但是需要在dev分支上开发，这时候需要做以下操作<br>      创建远程origin的dev分支到本地<br>      git checkout -b dev origin/dev<br>      假如git add 和git commit之后，git push origin dev 将dev分支推送到远程，此段时间别人也在将本地dev推送到远程，<br>      此时有可能发生冲突，发生冲突如何解决：<br>      git pull 将最新的提交从远程当前分支抓下来合并再提交<br>      这是git pull也失败了，怎么办：<br>      原因是没有指定本地dev分支和远程orgin/dev分支的链接，需要设置：<br>      git branch --set-upstream-to=origin/dev dev<br>      然后再git pull,会自动合并，若合并有冲突，可以修改冲突再提交git commit ,git push</p>\n\n        <h3 id=\"六.标签管理\">\n            <a href='#六.标签管理' class='header-anchor'>#</a>\n            <span>六.标签管理</span>\n        </h3>\n    <p>  1.创建标签<br>  tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起<br>  切换到要打标签的分支，比如dev分支<br>  git checkout dev<br>  给该分支打一个标签<br>  git tag v1.0 （git tag -a tagname -m &#39;描述文字&#39;）<br>  git tag 查看你打的历史标签<br>  删除标签<br>  git tag -d v1.0<br>  2.操作标签<br>  创建的标签都只存储在本地，不会自动推送到远程,可以这样将标签推送到远程<br>  git push origin v1.0<br>  也可以一次性将所有本地标签推送到远程<br>  git push origin --tags<br>  删除远程标签有点麻烦，需要先删除本地，再推送<br>  git tag -d -v1.0<br>  git push origin :refs/tags/v1.0</p>\n\n        <h3 id=\"七.忽略某些文件的上传\">\n            <a href='#七.忽略某些文件的上传' class='header-anchor'>#</a>\n            <span>七.忽略某些文件的上传</span>\n        </h3>\n    <p>建一个.gitignore文件，将需要忽略的文件或者文件夹名字写进去，然后将.gitignore提交到Git</p>\n\n        <h3 id=\"八.搭建私有git服务器\">\n            <a href='#八.搭建私有git服务器' class='header-anchor'>#</a>\n            <span>八.搭建私有git服务器</span>\n        </h3>\n    <p>1.安装git服务的环境<br>  yum -y install curl curl-devel zlib-devel openssl-devel perl cpio expat-devel gettext-devel gcc cc<br>2.下载 git-2.5.0.tar.gz<br>git官网下载：<a href=\"https://mirrors.edge.kernel.org/pub/software/scm/git/\">https://mirrors.edge.kernel.org/pub/software/scm/git/</a></p>\n<pre class=\"prettyprint\"><code>  解压\n  tar -xvzf git-2.5.0.tar.gz\n\n  cd git-2.5.0\n  autoconf\n  ./configure\n  make\n  make install</code></pre><p>3.添加用户<br>adduser -r -c &#39;git version control&#39; -d /home/irlen -m irlen<br>此命令执行后会创建/home/irlen目录作为irlen用户的主目录，用户名是irlen<br>进入home/irlen(irlen账户的家目录)。<br>4.设置密码为irlen<br>passwd irlen<br>这时候可以在主目录中建文件夹indus.git，进入indus.git 使用git init --bare 初始化目录,<br>进入.git文件夹，vim  config 在最后加上denyCurrentBranch = ignore</p>\n<p>5.本地连接远程私服<br>git remote add origin <a href=\"mailto:git@10.0.0.99\">git@10.0.0.99</a>:/home/irlen/indus.git</p>\n\n        <h3 id=\"在IDEA中使用git\">\n            <a href='#在IDEA中使用git' class='header-anchor'>#</a>\n            <span>在IDEA中使用git</span>\n        </h3>\n    <p>配置git<br>settings-&gt;Version Control-&gt;Git<br>工程加入到本地仓库<br>VCS-&gt;Import into Version Control-&gt;Create Git repository</p>\n"},{"context":[{"title":"运维","link":"javascript:void(0)"},{"title":"docker","link":"/ops/docker.html"}],"content":"\n        <h3 id=\"Doker\">\n            <a href='#Doker' class='header-anchor'>#</a>\n            <span>Doker</span>\n        </h3>\n    <p>仓库<br>镜像<br>容器</p>\n<p>下载地址：<br>    win10之外：<br>        <a href=\"https://www.docker.com/products/docker-toolbox\">https://www.docker.com/products/docker-toolbox</a><br>    win10:<br>        <a href=\"https://www.docker.com/products/docker#/windows\">https://www.docker.com/products/docker#/windows</a></p>\n<p>拉取镜像：<br>    docker pull  [options] name [:TAG]<br>查看已拉取的镜像：<br>    docker images [OPTIONS] REPROSITORY [:TAG]<br>运行一个镜像<br>    docker run [OPTIONS] IMAGE [:TAG] [COMMAND] [ARG...]</p>\n<pre class=\"prettyprint\"><code>-d参数表示在后台运行，并会打印出镜像ID</code></pre><p>查看正在机器上运行的容器<br>    docker ps<br>在容器中运行一个命令<br>    docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</p>\n\n        <h3 id=\"安装docker\">\n            <a href='#安装docker' class='header-anchor'>#</a>\n            <span>安装docker</span>\n        </h3>\n    <p>配置各种源的地址<br><a href=\"https://developer.aliyun.com/mirror/\">https://developer.aliyun.com/mirror/</a><br>安装前对centos的操作<br>1.yum包更新到最新<br>sudo yum update</p>\n<p>2.安装需要的包，yum-util提供yum-config-manager功能，另外两个是devicemapper驱动依赖。<br>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</p>\n<p>3.设置yum源为阿里云<br>sudo yum-config-manager --add-repo <a href=\"http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p>\n<p>4.安装docker<br>sudo yum install docker-ce -y</p>\n<p>5.设置ustc镜像（可以提升docker拉取镜像的速度）</p>\n<pre class=\"prettyprint\"><code>//创建文件\nsudo mkdir -p /etc/docker\nvim /etc/docker/daemon.json\n在文件中输入如下内容:\n{\n  &quot;registry-mirrors&quot;:[&quot;https://docker.mirrors.ustc.edu.cn&quot;]\n}</code></pre>\n        <h3 id=\"docker的启动和停止\">\n            <a href='#docker的启动和停止' class='header-anchor'>#</a>\n            <span>docker的启动和停止</span>\n        </h3>\n    <pre class=\"prettyprint\"><code>//启动\nsystemctl start docker\n//查看状态\nsystemctl status docker\n//开机自动启动\nsystemctl enable docker\n//关闭docker\nsystemctl stop docker</code></pre>\n        <h3 id=\"docker常用命令\">\n            <a href='#docker常用命令' class='header-anchor'>#</a>\n            <span>docker常用命令</span>\n        </h3>\n    <p>1.镜像相关操作命令</p>\n<pre class=\"prettyprint\"><code>  //查看docker中有哪些镜像\n    docker images\n\n  //搜索某个镜像\n    docker search centos  \n\n  //拉取镜像\n    docker pull tutum/centos\n\n  //删除镜像（按照ID或者名称都可以，如果镜像有相应容器运行，则该镜像无法删除）\n    docker rmi 镜像ID或者名称\n\n  //删除所有镜像\n    docker rmi `docker images -q`</code></pre><p>2.容器相关操作命令</p>\n<pre class=\"prettyprint\"><code>  //查看容器(正在运行的)\n    docker ps\n\n  //查看所有容器\n    docker ps -a\n\n  //创建与启动容器\n    docker run\n    参数 -i: 表示运行容器；\n\n         -t: (terminal 终端) 表示容器启动后进入命令行。加入这两个命令容器创建就可以进入，即分配一个伪终端；\n\n         --name: 为创建的容器命名；\n\n         -v: 表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个-v做多个目录和文件的映射。\n         注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。\n\n         -d: (daemons 守护进程) 在run后面加上-d参数，则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。\n\n         -p: (port) 表示端口映射，前者宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射；\n         (1)交互式运行一个容器\n         docker run -it --name=centos 镜像名:镜像标签  /bin/bash(表示使用bash脚本命令进行交互)\n         此时，容器运行，光标所在环境为容器环境。\n         退出容器环境\n         exit  (此时容器停止运行)\n\n         (2)守护式方式运行容器\n         docker run -id --name=mycentos2 镜像名:镜像标签\n         此时，容器运行中，光标在宿主机环境\n         进入容器环境\n         docker exec -it mycentos2 /bin/bash\n         然后 exit退出容器环境，此时容器仍然在运行（和交互式创建的容器不同）</code></pre><p>停止容器</p>\n<pre class=\"prettyprint\"><code>  docker stop mycentos2</code></pre><p>启动容器</p>\n<pre class=\"prettyprint\"><code>docker start mycentos2</code></pre><p>查看容器信息</p>\n<pre class=\"prettyprint\"><code>docker inspect 容器名称（或ID）\n//可查看指定参数 ，例如ip\ndocker inspect --format=&#039;{{.NetworkSettings.IPAddress}}&#039; 容器名称(或ID)</code></pre><p>删除容器（要先停止容器运行）<br>docker rm 容器名称（或ID）</p>\n\n        <h3 id=\"文件操作\">\n            <a href='#文件操作' class='header-anchor'>#</a>\n            <span>文件操作</span>\n        </h3>\n    <p>宿主环境下将文件拷入容器中</p>\n<pre class=\"prettyprint\"><code>docker cp haha.json mycentos2:/usr/local</code></pre><p>目录挂载<br>通过-v 参数在创建容器时，将宿主机和容器目录进行映射，之后通过修改宿主机某个文件去影响容器。<br>docker run -id -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos2 centos:7<br>多级目录可能无权限,可添加 --privileged=true 来解决。（privileged 有特权的）</p>\n\n        <h3 id=\"mysql部署\">\n            <a href='#mysql部署' class='header-anchor'>#</a>\n            <span>mysql部署</span>\n        </h3>\n    <p>1.拉取mysql镜像<br>docker pull centos/mysql-57-centos7   //拉取mysql5版本镜像</p>\n<p>2.创建容器<br>docker run -id --name=mymysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=irlen 镜像名称<br>此时可用宿主机的ip和映射端口去连容器内mysql</p>\n\n        <h3 id=\"tomcat部署\">\n            <a href='#tomcat部署' class='header-anchor'>#</a>\n            <span>tomcat部署</span>\n        </h3>\n    <p>1.拉取tomcat镜像<br>docker pull tomcat:7-jre7</p>\n<p>2.创建容器(-p：端口映射，-v:目录映射)<br>docker -id --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/user/local/tomcat/webapps  tomcat:7-jre7</p>\n\n        <h3 id=\"Nginx部署\">\n            <a href='#Nginx部署' class='header-anchor'>#</a>\n            <span>Nginx部署</span>\n        </h3>\n    <p>1.拉取Nginx镜像<br>  docker pull nginx<br>2.创建nginx容器<br>  docker run -id --name=mynginx -p 80:80 nignx</p>\n\n        <h3 id=\"Redis部署\">\n            <a href='#Redis部署' class='header-anchor'>#</a>\n            <span>Redis部署</span>\n        </h3>\n    <p>1.拉取Redis镜像<br>docker pull redis<br>2.创建容器<br>docker run -id --name=myredis -p 6379:6379 redis</p>\n\n        <h3 id=\"迁移与备份\">\n            <a href='#迁移与备份' class='header-anchor'>#</a>\n            <span>迁移与备份</span>\n        </h3>\n    <p>1.容器保存为镜像<br>  docker commit mynginx mynginx_i<br>2.镜像备份<br>  docker save -o mynginx.tar mynginx_i  //-o  output意思<br>3.镜像恢复与迁移<br>  docker load -i mynginx.tar  //-i input的意思</p>\n\n        <h3 id=\"Dockerfile常用命令\">\n            <a href='#Dockerfile常用命令' class='header-anchor'>#</a>\n            <span>Dockerfile常用命令</span>\n        </h3>\n    <p>Dockerfile是由一系列命令和参数构成的脚本，用于基础镜像并最终创建一个新的镜像。<br>常用命令</p>\n<pre class=\"prettyprint\"><code>FROM  镜像名   //从哪个基础镜像启动构建流程\nMANITAINER irlen //创建进行的作者\nENV  key:value  //设置环境变量（可写多条）\nRUN  命令  //dockerfile核心部分（可写多条）\nADD  宿主文件 容器文件  //将宿主文件复制到容器内，如果是压缩文件会自动解压\nCOPY 宿主文件 容器文件  //同上，但是压缩文件不会自己解压\nWORKDIR 文件夹  //设置工作目录</code></pre>\n        <h3 id=\"使用Dockerfile创建镜像（脚本文件名称必须叫Dockerfile）\">\n            <a href='#使用Dockerfile创建镜像（脚本文件名称必须叫Dockerfile）' class='header-anchor'>#</a>\n            <span>使用Dockerfile创建镜像（脚本文件名称必须叫Dockerfile）</span>\n        </h3>\n    <pre class=\"prettyprint\"><code>example: 用Dockerfile创建一个jdk1.8的镜像\n文件名称 Dockerfile\n文件内容\n  FROM centos:7\n  MANITAINER irlen\n  WORKDIR /usr\n  RUN mkdir /usr/local/java\n  ADD jdk-yu171-linux-x64.tar.gz /usr/local/java/\n\n  ENV JAVA_HOME /usr/local/java/jdk1.8.0_171\n  ENV JRE_HOME $JAVA_HOME/jre\n  ENV CLASSPATH $JAVA_HOME/bin/dt.jar:$JAVA_HJOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH   //linux用冒号代表分号\n  ENV PATH $JAVA_HOME/bin:$PATH\n\n  //执行Dockerfile创建镜像\n  docker build -t=&quot;镜像名称&quot; .   //.表示在当前文件中寻找Dockerfile文件\n</code></pre>\n        <h3 id=\"Docker私有仓库\">\n            <a href='#Docker私有仓库' class='header-anchor'>#</a>\n            <span>Docker私有仓库</span>\n        </h3>\n    <p>私有仓库搭建与配置<br>1.拉取私有仓库镜像（私有仓库本身也是一个镜像）<br>  docker pull registry<br>2.启动私有仓库容器<br>  docker run -id --name=registry -p 5000:5000 registry<br>3.打开浏览器查看host:5000/v2/_catalog看到{&quot;repositories&quot;:[]} 表示私有仓库搭建成功并且内容为空。</p>\n<p>4.修改daemon.json  让docker信任私有仓库地址。</p>\n<pre class=\"prettyprint\"><code>vim /etc/docker/daemon.json\n添加(host为宿主机ip)\n{\n  “insecure-registries”:[host地址:5000]\n}\n重启docker服务\nsystemctl restart docker</code></pre><p>将镜像上传到私有仓库（私有仓库容器需要启动）<br>docker tag 镜像名 私服地址:端口/镜像名<br>docker push 私服地址:端口/镜像名</p>\n<p>从私有仓库下载镜像</p>\n"},{"context":[{"title":"运维","link":"javascript:void(0)"},{"title":"nginx","link":"/ops/nginx.html"}],"content":"\n        <h3 id=\"环境\">\n            <a href='#环境' class='header-anchor'>#</a>\n            <span>环境</span>\n        </h3>\n    <p>centos7.2<br>查看防火墙状态</p>\n<pre class=\"prettyprint\"><code>  systemctl status firewall.service</code></pre><p>关闭防火墙</p>\n<pre class=\"prettyprint\"><code>  systemctl stop firewall.service</code></pre><p>查看SELinux状态(安全增强型linux,SELinux是专门为linux内核制作的安全模块。)</p>\n<pre class=\"prettyprint\"><code>  getenforce</code></pre><p>临时关闭SELinux</p>\n<pre class=\"prettyprint\"><code>  setenforce 0</code></pre><p>Nginx是一个开源且高性能，可靠的HTTP中间件，代理服务。<br>类似的有 HTTPD（来自Apache基金会），IIS(来自微软)</p>\n"},{"context":[{"title":"运维","link":"javascript:void(0)"},{"title":"linux","link":"/ops/linux.html"}],"content":"\n        <h3 id=\"cenos7安装\">\n            <a href='#cenos7安装' class='header-anchor'>#</a>\n            <span>cenos7安装</span>\n        </h3>\n    <p>以镜像文件安装的方式安装。<br>#.源码安装wget###########################################<br>  源码下载地址：<a href=\"ftp://ftp.gnu.org/gnu/wget/\">ftp://ftp.gnu.org/gnu/wget/</a><br>  解压源码： tar -zxvf file.tar<br>  执行配置： ./config --prefix=/usr/local/wget  检测目标特性，生成makefile文件(prefix参数是配置wget的安装目录)<br>  执行：make clean;  make 编译<br>  安装：make install<br>  在/bin中创建软链接 ln -s /local/usr/wget/bin/wget  wget</p>\n<p>#.安装vim （有些版本需要重新安装vim）###########################################<br>查询 ：rpm -qa|grep vim<br>yum 源安装失败，选择源码安装<br>源码下载地址 <a href=\"https://github.com/vim/vim/releases\">https://github.com/vim/vim/releases</a><br>解压源码： tar -zxvf file.tar<br>执行配置： ./config --prefix=/usr/local/vim  检测目标特性，生成makefile文件(prefix参数是配置wget的安装目录)<br>执行：make clean;  make 编译<br>安装：make install<br>在/bin中创建软链接 ln -s /local/usr/wget/bin/vim  vim</p>\n<p>#配置桥接网络############################################################<br>虚拟机-设置-网络适配器，选择桥接模式<br>编辑-虚拟网络编辑器-更改设置-桥接到-Realtec PCIe GBE Family Controller<br>查看宿主机DNS地址 (window系统)<br>ipconfig /all   查看DNS和Ip,网关</p>\n<p>修改Centos7网络适配文件<br>编辑vim  /etc/sysconfig/network-scripts/ifcfg-ens33<br>BOOTPROTO = static  //自动分配改成静态<br>ONBOOT = yes //开机启动<br>IPADDR = 10.0.0.99 //必须和宿主机在同一网关，即 A类地址前三位要一样<br>GATEWAY = 10.0.0.1 //网关要与宿主机一致<br>NETMASK = 255.255.255.0  //A类地址子网掩码<br>DNS1= 10.0.0.1 //与宿主机一致<br>重启网络<br>service network restart</p>\n<p>#安装python3##############################################################<br>python -V //查看目前安装的版本<br>先安装用于下载编译python3的相关包<br>yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make<br>备份Python2<br>mv python python.bak<br>下载python3资源包<br>wget <a href=\"https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tar.xz\">https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tar.xz</a><br>解压检测安装<br>tar -xvJf  Python-3.6.8.tar.xz<br>./configure --prefix=/local/usr/python3/ 安装python3<br>make clean<br>make<br>make install<br>添加软链接到/bin<br>ln -s /local/usr/python3/bin/python3 python<br>此时yum不能正常使用，需要将vi /usr/bin/yum中python改为python2</p>\n<p>#安装mysql#################################################################</p>\n<p>1.先删除系统中存下的有关mysql的文件<br>yum remove  mysql mysql-server mysql-libs mysql-server;<br>find / -name mysql 将找到的相关东西delete掉(rm -rf /var/lib/mysql)；<br>rpm -qa|grep mysql (qa指query all，查询所有rpm包，查询出来的东东yum remove掉)<br>rm /etc/my.cnf<br>rpm安装的mysql，则查找卸载并删除其服务<br>a)查找mysql<br>[root@localhost opt]# rpm -qa | grep -i mysql<br>MySQL-server-5.6.17-1.el6.i686<br>MySQL-client-5.6.17-1.el6.i686</p>\n<p>b)卸载mysql</p>\n<p>[root@localhost local]# rpm -e MySQL-server-5.6.17-1.el6.i686<br>[root@localhost local]# rpm -e MySQL-client-5.6.17-1.el6.i686</p>\n<p>c)删除mysql服务</p>\n<p>[root@localhost local]# chkconfig --list | grep -i mysql<br>[root@localhost local]# chkconfig --del mysql<br>删除yum remove mariadb</p>\n<p>安装新的mysql<br>1.找到mysql资源包<br><a href=\"https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.13-1.el7.x86_64.rpm-bundle.tar\">https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.13-1.el7.x86_64.rpm-bundle.tar</a><br>2.用wget下载到服务器<br>wget <a href=\"https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.13-1.el7.x86_64.rpm-bundle.tar\">https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.13-1.el7.x86_64.rpm-bundle.tar</a><br>3.解压包<br>tar -xvf mysql-8.0.13-1.el7.x86_64.rpm-bundle.tar<br>4.安装mysql<br>rpm -vih XXXXXX（XXXXXX 为 rpm包全名，按照依赖按顺序安装）<br>mysql-community-common-8.0.13-1.el7.x86_64<br>mysql-community-libs-8.0.13-1.el7.x86_64<br>mysql-community-libs-compat-8.0.13-1.el7.x86_64<br>mysql-community-client-8.0.13-1.el7.x86_64<br>mysql-community-embedded-compat-8.0.13-1.el7.x86_64</p>\n<p>mysql-community-server-8.0.13-1.el7.x86_64<br>mysql-community-devel-8.0.13-1.el7.x86_64<br>mysql-community-test-8.0.13-1.el7.x86_64<br>5.启动mysql服务<br>service mysqld restart<br>6.首次无密码登录<br>mysql -u root<br>如果出现1045（28000）错误,<br>vim /etc/my.cnf<br>在[mysqld]后面任意一行添加“skip-grant-tables”用来跳过密码验证的过程<br>然后重启 service mysqld restart<br>7.设置密码 （很多时候设置不成功是因为密码规则不匹配）<br>UPDATE user SET Password = PASSWORD(&#39;12345678&#39;) WHERE user = &#39;root&#39;;<br>SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(123456);<br>下面是我的密码规则，更新密码语句，执行下面的语句就不报上面的语法错误了：<br>下面两种都可以修改密码<br>ALTER user &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;12345678&#39;;<br>或<br>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;12345678&#39;;<br>查看 mysql 初始的密码策略<br>mysql&gt; SHOW VARIABLES LIKE &#39;validate_password%&#39;;<br>关于 mysql 密码策略相关参数；<br>1）、validate_password_length  固定密码的总长度；<br>2）、validate_password_dictionary_file 指定密码验证的文件路径；<br>3）、validate_password_mixed_case_count  整个密码中至少要包含大/小写字母的总个数；<br>4）、validate_password_number_count  整个密码中至少要包含阿拉伯数字的个数；<br>5）、validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM；<br>关于 validate_password_policy 的取值：<br>0/LOW：只验证长度；<br>1/MEDIUM：验证长度、数字、大小写、特殊字符；<br>2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；<br>6）、validate_password_special_char_count 整个密码中至少要包含特殊字符的个数；<br>只要修改密码强度等级就可以，就可以解决密码策略问题<br>set global validate_password.policy=LOW;<br>或者<br>set global validate_password.policy=0;(我用的这条)<br>刷新<br>FLUSH PRIVILEGES;</p>\n<p>二.yum安装数据库<br>cat /etc/redhat-release<br>yum install mysql<br>yum install mysql-server<br>yum install mysql-devel<br>设置密码<br>mysql set password for &#39;root&#39;@&#39;localhost&#39;=password(&#39;irlen&#39;)</p>\n<p>设置让所有主机可连接数据库<br>登录数据库<br>mysql -uroot -p<br>切换到mysql数据库<br>mysql&gt; use mysql;<br>设置user表中所有主机有权使用root的用户名登录<br>uapdate user set host=&#39;%&#39; where user=&#39;root&#39;;<br>授权所有主机可以root用户名访问数据库<br>GRANT PRIVILEGES ON  <em>.</em> tO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;root&#39; WITH GRANT OPTION;<br>查看是否更改成功<br>mysql&gt; select host, user from user;<br>刷新权限表<br>mysql&gt; flush privileges<br>开启3306端口<br>firewall-cmd --zone=public --add-port=3306/tcp --permanent<br>然后重启防火墙</p>\n\n        <h3 id=\"防火墙相关操作###########################################################\">\n            <a href='#防火墙相关操作###########################################################' class='header-anchor'>#</a>\n            <span>防火墙相关操作###########################################################</span>\n        </h3>\n    <ol>\n<li>查看防火墙状态<br>firewall-cmd --state            ## 结果显示为running或not running</li>\n<li>关闭防火墙firewall<br>systemctl stop firewalld.service<br>systemctl disable firewalld.service</li>\n<li>关闭防火墙firewall后开启<br>systemctl start firewalld.service</li>\n<li>开启端口\n        <h2 id=\"zone-作用域\">\n            <a href='#zone-作用域' class='header-anchor'>#</a>\n            <span>zone -- 作用域</span>\n        </h2>\n    \n        <h2 id=\"add-port=80/tcp-添加端口，格式为：端口/通讯协议\">\n            <a href='#add-port=80/tcp-添加端口，格式为：端口/通讯协议' class='header-anchor'>#</a>\n            <span>add-port=80/tcp -- 添加端口，格式为：端口/通讯协议</span>\n        </h2>\n    \n        <h2 id=\"permanent-永久生效，没有此参数重启后失效\">\n            <a href='#permanent-永久生效，没有此参数重启后失效' class='header-anchor'>#</a>\n            <span>permanent -- 永久生效，没有此参数重启后失效</span>\n        </h2>\n    firewall-cmd --zone=public --add-port=3306/tcp --permanent\n        <h2 id=\"开启3306端口后，workbench或naivcat-就能连接到MySQL数据库了\">\n            <a href='#开启3306端口后，workbench或naivcat-就能连接到MySQL数据库了' class='header-anchor'>#</a>\n            <span>开启3306端口后，workbench或naivcat 就能连接到MySQL数据库了</span>\n        </h2>\n    查看某个端口是否开启<br>firewall-cmd --query-port=80/tcp</li>\n</ol>\n<ol start=\"5\">\n<li>重启防火墙<br>firewall-cmd --reload<br>大多数是由于系统里面安装的python版本原因。/usr/sbin/firewalld文件头部的python版本和安装的python版本不一致</li>\n<li>常用命令介绍<br>firewall-cmd --state                           ##查看防火墙状态，是否是running<br>firewall-cmd --reload                          ##重新载入配置，比如添加规则之后，需要执行此命令<br>firewall-cmd --get-zones                       ##列出支持的zone<br>firewall-cmd --get-services                    ##列出支持的服务，在列表中的服务是放行的<br>firewall-cmd --query-service ftp               ##查看ftp服务是否支持，返回yes或者no<br>firewall-cmd --add-service=ftp                 ##临时开放ftp服务<br>firewall-cmd --add-service=ftp --permanent     ##永久开放ftp服务<br>firewall-cmd --remove-service=ftp --permanent  ##永久移除ftp服务<br>firewall-cmd --add-port=80/tcp --permanent     ##永久添加80端口<br>iptables -L -n                                 ##查看规则，这个命令是和iptables的相同的<br>man firewall-cmd                               ##查看帮助<br>systemctl status firewalld.service                               ##查看防火墙状态<br>systemctl [start|stop|restart] firewalld.service                 ##启动|关闭|重新启动  防火墙</li>\n</ol>\n<p>##查询端口号80 是否开启<br>firewall-cmd --query-port=80/tcp<br>更多命令，使用 firewall-cmd --help 查看帮助文件</p>\n<p>重启网络<br>centos6的网卡重启方法：service network restart<br>centos7的网卡重启方法：systemctl restart network</p>\n<p>安装nodejs################################################################################################################<br>1、确认依赖环境</p>\n<p>确认服务器有nodejs编译及依赖相关软件，如果没有可通过运行以下命令安装。</p>\n<p>yum -y install gcc gcc-c++ openssl-devel<br>2.现在需要的版本<br><a href=\"http://nodejs.org/dist/\">http://nodejs.org/dist/</a></p>\n<p>3.解压之后创建软链接使得全局可用<br>ln s node所在的位置  /usr/local/bin/node<br>ln s npm所在的位置  /usr/local/bin/npm</p>\n<p>5.验证<br>任意地点执行node -v<br>6.配置npm镜像<br>npm config set registry <a href=\"https://registry.npm.taobao.org\">https://registry.npm.taobao.org</a><br>npm config get registry<br>npm install -g cnpm --registry=<a href=\"https://registry.npm.taobao.org\">https://registry.npm.taobao.org</a></p>\n<p>安装装yarn<br>1.在 CentOS, Fedora 和 RHEL 操作系统上，你可以通过我们的 RPM 包仓库来安装 Yarn。</p>\n<p>sudo wget <a href=\"https://dl.yarnpkg.com/rpm/yarn.repo\">https://dl.yarnpkg.com/rpm/yarn.repo</a> -O /etc/yum.repos.d/yarn.repo<br>　　如果你尚未安装 Node.js（查看是否安装node.js用命令：node -v就可以显示版本。安装方法参考CentOS 下安装 Node.js 8.11.3 LTS Version），你应该配置 Node 源仓库：</p>\n<p>curl --silent --location <a href=\"https://rpm.nodesource.com/setup_6.x\">https://rpm.nodesource.com/setup_6.x</a> | bash -<br>2.然后运行：</p>\n<p>sudo yum install yarn<br>　　这样就安装完成了。查看yarn版本用命令：yarn --version</p>\n<p>安装pipenv ####################################################################<br>pip install -i <a href=\"https://pypi.tuna.tsinghua.edu.cn/simple\">https://pypi.tuna.tsinghua.edu.cn/simple</a> pipenv    使用国内源安装pipenv</p>\n<p>mkdir fisher</p>\n<p>进入文件夹，执行pipenv shell 启动pipenv</p>\n<p>在pipenv虚拟环境中执行：</p>\n<p>pip3 list 查看这个虚拟环境有哪些安装包</p>\n<p>pipenv graph 可以查看依赖关系</p>\n<p>pipenv install  flask 安装包</p>\n<p>pipenv --venv查看这个虚拟环境所属目录，在pycharm中添加</p>\n\n        <h3 id=\"window宿主机和linux虚拟机通信\">\n            <a href='#window宿主机和linux虚拟机通信' class='header-anchor'>#</a>\n            <span>window宿主机和linux虚拟机通信</span>\n        </h3>\n    <p>1.host-only<br> 宿主机windows与虚拟机linux单独组网，即让虚拟机与宿主机位于不同的各自独立的IP地址，但是不与宿主机位于同一网段，<br> 同时为宿主机新增一个ip地址，且保证该IP地址与其他虚拟机ip位于同一网段。最终新建了一个由所有虚拟机和宿主机构成的局域网，<br> 但是该局域网与宿主机本身所处的现有局域网是相互独立的，是无法之间通信的，达到网络隔离的效果。<br> 实际上是为宿主机新添加了一个虚拟网卡，使宿主机变成一个双网卡的主机，同时宿主机后端设一个虚拟交换机，<br> 让宿主机与所有的虚拟机构成一个虚拟的局域网达到相互通信的目的，但是虚拟的局域网与宿主机所处的实际局域网是无法直接通信的。</p>\n<p>2.桥接的连接方式</p>\n<p> 宿主机windows与虚拟机linux在同一个局域网，即让虚拟机与宿主机拥有不同的IP地址但是同在一个网段内，也就是在宿主机当前的局域网添加多个虚拟机</p>\n<p>3.NAT</p>\n<p>表面上看，虚拟机没有自己的ip，是和宿主机共享IP地址，但本质上是基于Host-only方式，即虚拟机还是有自己独立的IP地址，<br>但是实际不投入使用，NAT方式跟host-only方式一样为宿主机新添加一个虚拟网卡使之成为双网卡主机。使其同时参与自身现有的局域网和虚拟的局域网。而NAT方式不同于host-only的是，它加设了一个NAT服务器，使得虚拟局域网内的虚拟机对外访问时，完全使用的是宿主机的IP地址，所以对于外界网络来说看到的只有宿主机，而新建的虚拟局域网是透明的。</p>\n<p>配置方式：</p>\n"},{"context":[{"title":"正则","link":"javascript:void(0)"},{"title":"正则","link":"/regexp/regexp.html"}],"content":"\n        <h3 id=\"1.简介\">\n            <a href='#1.简介' class='header-anchor'>#</a>\n            <span>1.简介</span>\n        </h3>\n    <p>普通字符： 包括没有显式指定为元字符的所有可打印和不可打印字符，包括大小写字母，所有数字，所有标点符号和一些其他字符。<br>非打印字符： \\f     匹配一个换页符，<br>                     \\n    匹配一个换行符，<br>                     \\r     匹配一个回车符，<br>                     \\s     匹配任何空格字符，包括空格制表符，换页符等（Unicode正则表达式会匹配全角空格符）,<br>                     \\S    匹配任何非空白字符，<br>                     \\t     匹配一个制表符，<br>                     \\v    匹配一个垂直制表符</p>\n<p>特殊字符：就是有特殊含义的字符，如果查找其本身，需要用\\进行转义<br>$    匹配字符串的结尾位置（如果设置了RegExp对象的Multiline属性，则$也匹配\\n或者\\r），<br>^    匹配夫字符串的开始位置，若在方括号表达式中使用，此时它表示不接受该字符结合</p>\n<ul>\n<li>匹配前面的子表达式0次或多次，</li>\n</ul>\n<ul>\n<li>匹配前面子表达式一次或者多次<br>?     匹配前面子表达式零次或一次，或者指定一个非贪婪限定符。</li>\n</ul>\n<p>.    匹配除换行符\\n之外的任意单字符</p>\n<p>()    标记一个子表达式的开始和结束位置，子表达式可以获取供以后使用，<br>[]    匹配一个中括号表达式的开始和结束，一般指一系列字符集合<br>{}    限定表达式的开始和结束符号，一般内表达式限定字符的长度或者范围</p>\n<p>\\     将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符<br>|    指明两项中间选择其一</p>\n<p>限定符：限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。</p>\n<ul>\n<li>匹配前面子表达式零次或多次，</li>\n</ul>\n<ul>\n<li>匹配前面子表达式一次或多次，<br>?    匹配面前子表达式零次或一次，<br>{n}    n是一个非负整数，匹配确定的n次,<br>{n,}    n是一个非负整数，至少匹配n次，<br>{n,m}    m和n均为非负整数，其中n&lt;=m,表示最少匹配n次，最多匹配m次（在逗号和两个数之间不能有空格），</li>\n</ul>\n<p>定位符：定位符用来描述字符串或单词的边界，<br>^    匹配输入字符串开始的位置（如果设置了RegExp对象的Multiline属性，^还会与\\n或者\\r之后的位置匹配）<br>$    匹配输入字符串结尾的位置（如果设置了RegExp对象的Multiline属性，^还会与\\n或者\\r之前的位置匹配）<br>\\b    匹配一个单词边界，即字与空格之间的位置<br>\\B    非单词边界匹配<br>注意： 不能将定位符和限定符一起使用，由于在紧靠换行或者单词边界的前面或者后面不能有一个以上的位置，因此不允许诸如^*之类的表达式。</p>\n<p>选择：用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。<br>其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。<br>反向引用：对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。<br>可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。<br>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。<br>i表示不区分大小写，g表示全局匹配</p>\n\n        <h3 id=\"2.元字符\">\n            <a href='#2.元字符' class='header-anchor'>#</a>\n            <span>2.元字符</span>\n        </h3>\n    <p>\\    将下一个字符标记为一个特殊字符，或一个原意字符，或一个向后引用，或一个八进制转义符。<br>^      匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 &#39;\\n&#39; 或 &#39;\\r&#39; 之后的位置。<br>$     匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 &#39;\\n&#39; 或 &#39;\\r&#39; 之前的位置。</p>\n<ul>\n<li>匹配前面的子表达式零次或多次</li>\n</ul>\n<ul>\n<li>匹配前面子表达式一次或多次<br>？    匹配前面子表达式零次或一次， 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例            如，对于字符串 &quot;oooo&quot;，&#39;o+?&#39; 将匹配单个 &quot;o&quot;，而 &#39;o+&#39; 将匹配所有 &#39;o&#39;。<br>{n}    n是一个非负整数，匹配确定的n次<br>{n,}    n是一个非负整数，至少匹配n次<br>{n,m}    n和m皆为非负整数，n&lt;=m，至少匹配n次，至多匹配m次<br>(pattern)    匹配括号中pattern，并获取这一匹配，所获取的匹配可以从产生的matches集合中得到，在js中则使用$0...$9属性。<br>(?:pattern)    匹配pattern ，但不获取匹配结果，  &#39;industr(?:y|ies) 就是一个比 &#39;industry|industries&#39; 更简略的表达式<br>(?=pattern)    正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，这是一个非获取匹配， 例如，&quot;Windows(?=95|98|NT|2000)&quot;能匹配&quot;Windows2000&quot;中的&quot;Windows&quot;，但不能匹配&quot;Windows3.1&quot;中的&quot;Windows&quot;<br>(?!pattern)     正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，这是一个非获取匹配， 例如&quot;Windows(?!95|98|NT|2000)&quot;能匹配&quot;Windows3.1&quot;中的&quot;Windows&quot;，但不能匹配&quot;Windows2000&quot;中的&quot;Windows&quot;<br>(?&lt;=pattern) 反向肯定预查，与正向肯定预查类似，只是方向相反， 例如，&quot;(?&lt;=95|98|NT|2000)Windows&quot;能匹配&quot;2000Windows&quot;中的&quot;Windows&quot;，但不能匹配&quot;3.1Windows&quot;中的&quot;Windows&quot;<br>(?&lt;!pattern)  反向否定预查，与正向否定预查类似，只是方向相反，例如，&quot;(?&lt;!95|98|NT|2000)Windows&quot;能匹配&quot;3.1Windows&quot;中的&quot;Windows&quot;,但不能匹配&quot;2000Windows&quot;中的&quot;Windows&quot;<br>x|y    匹配x或者y<br>[xyz]    字符集合，匹配包含的任意一个字符， 例如， &#39;[abc]&#39; 可以匹配 &quot;plain&quot; 中的 &#39;a&#39;<br>[^xyz] 匹配未包含的任意字符， 例如， &#39;[^abc]&#39; 可以匹配 &quot;plain&quot; 中的&#39;p&#39;、&#39;l&#39;、&#39;i&#39;、&#39;n&#39;<br>[a-z]     匹配a-z范围内的所有字符<br>[^a-z]    匹配a-z范围以外的所有字符<br>\\b    匹配一个单词边界，也就是单词和空格之间的位置， 例如， &#39;er\\b&#39; 可以匹配&quot;never&quot; 中的 &#39;er&#39;，但不能匹配 &quot;verb&quot; 中的 &#39;er&#39;。<br>\\B    匹配非单词边界，例如， &#39;er\\B&#39; 能匹配 &quot;verb&quot; 中的 &#39;er&#39;，但不能匹配 &quot;never&quot; 中的 &#39;er&#39;。<br>\\cx  匹配由x指明的控制符，c相当于control,例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 &#39;c&#39; 字符。<br>\\d    匹配一个数字字符，等价于[0-9].<br>\\D    匹配一个非数字字符，等价于[^0-9]<br>\\w    匹配字母，数字，下划线。等价于[A-Za-z0-9_]<br>\\W    匹配非字符数字下划线。等价于[^A-Za-z0-9_]<br>\\f    匹配一个换页符， 等价于 \\x0c 和 \\cL。<br>\\n    匹配一个换行符，等价于 \\x0a 和 \\cJ<br>\\r    匹配一个回车符，等价于\\x0d和\\cM<br>\\t    匹配一个指标符，等价于\\x09和\\cl<br>\\v    匹配一个垂直制表符，等价于\\x0b和\\cK<br>\\s    匹配任何空白字符，包括空格，制表符，换页等等，等价于[\\f\\n\\r\\t\\v]<br>\\S    匹配任何非空白字符，等价于[^\\f\\n\\r\\t\\v]</li>\n</ul>\n<p>\\xn    匹配n,其中n为一个十六进制转意值。十六进制转移值必须为确定的两个数字长。例如： &quot;\\x41&quot;匹配“A”，&quot;\\x041&quot;则等价于&quot;\\x04&quot;&amp;&quot;1&quot;。正则表达式可以使用ASII编码。<br>\\num    匹配num，其中num是一个正整数。对所获取的匹配的应用。例如，&#39;(.)\\1&#39;匹配两个连续的相同字符。<br>\\n     标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。<br>\\nm     标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。<br>\\nml     如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。<br>\\un         匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。</p>\n<p>i：ignorCase忽略大小写<br>m：mutiple允许多行匹配<br>g：globle进行全局匹配，指匹配到目标串的结尾</p>\n<p>3.运算优先级<br>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。<br>相同优先级的从左到右进行运算，不同优先级的运算先高后低。<br>下面表格优先级从高到低排列<br><img src=\"../docs/regexp/youxianji.png\" alt=\"优先级\"></p>\n"}];

  var escapeHtml = function (html) {
    let str = html;
    str = str.replace(/&/g, '&amp;');
    str = str.replace(/</g, '&lt;');
    str = str.replace(/>/g, '&gt;');
    str = str.replace(/"/g, '&quot;');
    str = str.replace(/'/g, '&#039;');
    return str;
  }

  var clearHtml = function (html) {
    let str = html;
    str = str.replace(/&amp;/g, '');
    str = str.replace(/&lt;/g, '');
    str = str.replace(/&gt;/g, '');
    str = str.replace(/&quot;/g, '');
    str = str.replace(/&#039;/g, '');
    return str;
  }

  var randStr = function () {
    return Math.random().toString(36).substr(2);
  };

  var findTitle = function (ele) {
    var findPrevs = function (ele) {
      var children = $(ele).parent().children();
      var prevs = [];
      var findIt = false;
      children = Array.prototype.slice.call(children);
      children.forEach(function (subEle) {
        if ($(subEle).is($(ele))) {
          findIt = true;
        }
        if (findIt === false && $(subEle).text() != "") {
          prevs.push(subEle);
        }
      });
      return prevs;
    };

    var findH = function (eles) {
      var _eles = Array.prototype.slice.call(eles);
      _eles.reverse();
      var title = "";
      var id = "";
      _eles.forEach(function (item) {
        if (!title) {
          if (item.nodeName[0] === "H") {
            title = $(item).text();
            id = $(item).attr("id");
          }
        }
      });
      return {
        text: title,
        id: id
      };
    };
    var prevs = findPrevs(ele);
    if (prevs.length) {
      return findH(prevs);
    }
  };

  window.searchData = function (keyword) {
    var searchResult = [];
    content.forEach(function (item, index) {
      var tempHtml = "<div id='" + randStr() + "'></div>";
      var tempEle = $(tempHtml);
      var findArray = [];
      tempEle.html(clearHtml(item.content));
      findArray = tempEle.find(":contains('" + keyword + "')");
      findArray = Array.prototype.slice.call(findArray);
      if (findArray.length) {
        findArray.forEach(function (ele) {
          var findContent = $(ele).text();
          findContent = findContent[0] === "<" ? $(findContent).text() : findContent;
          findContent = escapeHtml(findContent);
          findContent = findContent.replace(new RegExp(keyword, 'g'), "<b>" + keyword + "</b>");
          var hObj = findTitle(ele);
          if (hObj) {
            searchResult.push({
              context: item.context,
              title: hObj.text,
              hid: hObj.id,
              findContent: findContent
            });
          }
        });
      }
    });
    return searchResult;
  };
})();
(function () {
  var content = [{"context":[{"title":"介绍","link":"/index.html"}],"content":"\n        <h3 id=\"此文档主要用于学习记录\">\n            <a href='#此文档主要用于学习记录' class='header-anchor'>#</a>\n            <span>此文档主要用于学习记录</span>\n        </h3>\n    <p>最近修改于2020年03月23日<br>github地址：<a href=\"https://github.com/irlen/note\">https://github.com/irlen/note</a></p>\n"},{"context":[{"title":"大前端","link":"javascript:void(0)"},{"title":"react","link":"javascript:void(0)"},{"title":"react-hooks","link":"/front/react/react-hooks.html"}],"content":"\n        <h3 id=\"react-hooks\">\n            <a href='#react-hooks' class='header-anchor'>#</a>\n            <span>react-hooks</span>\n        </h3>\n    <p>为什么只能在函数最外层调用 Hook，不要在循环、条件判断或者子函数中调用？<br>为什么 useEffect 第二个参数是空数组，就相当于 ComponentDidMount ，只会执行一次？<br>React Hooks 分为内置的和自定义的两种类型，内置的 hooks 有以下几个：</p>\n\n        <h3 id=\"Basic-Hooks\">\n            <a href='#Basic-Hooks' class='header-anchor'>#</a>\n            <span>Basic Hooks</span>\n        </h3>\n    <p>useState<br>useEffect<br>useContext</p>\n\n        <h3 id=\"Additional-HooksuseReducer\">\n            <a href='#Additional-HooksuseReducer' class='header-anchor'>#</a>\n            <span>Additional HooksuseReducer</span>\n        </h3>\n    <p>useCallback<br>useMemo<br>useRef<br>useImperativeHandle<br>useLayoutEffect<br>useDebugValue</p>\n\n        <h3 id=\"1.useState\">\n            <a href='#1.useState' class='header-anchor'>#</a>\n            <span>1.useState</span>\n        </h3>\n    <p>const [count,setCount] = useState(0);<br>setCount(),可直接输入要设置的值，也可以传入带参数函数，参数为上一次count值，经过计算处理返回。</p>\n<pre class=\"prettyprint\"><code>  setCount(previous=&amp;gt;{\n    return revious+10\n  })</code></pre><p>注意： useState 的参数可以是基本类型，也可以是对象类型，在更新对象类型时，切记要合并旧的状态，否则旧的状态会丢失</p>\n<pre class=\"prettyprint\"><code>setCount({\n  ...params,\n  countone: 200\n})</code></pre>\n        <h3 id=\"2.useEffect/useLayoutEffect\">\n            <a href='#2.useEffect/useLayoutEffect' class='header-anchor'>#</a>\n            <span>2.useEffect/useLayoutEffect</span>\n        </h3>\n    <p>useEffect是ReactHooks的核心,可取代componentDidMount、componentDidUpdate、componentWillUnmount三个周期。<br>useEffect接受两个参数，其中第二个参数是可选的，不过一般情况下都需要传入第二个参数。</p>\n<pre class=\"prettyprint\"><code>useEffect(()=&amp;gt;{\n\n    return ()=&amp;gt;{}\n},[])</code></pre><p>第一个参数为一个函数，为必传参数，当组件数次渲染或者其依赖的状态改变时会执行，该函数的返回值是可选的，可以不写，如果要写的话必须是一个函数，用于清除上一个状态。</p>\n<p>第二个参数为可选参数，是一个数组。数组中可以传入状态值（通过useState产生的值），当状态值改变的时候首先会执行return函数（即第一个参数中函数的返回值函数），用于清理上一个状态，然后useEffect中的函数就会再次执行。</p>\n<p>***如果不传入第二个参数，代表组件中任何状态的改变，effect都会执行一次，这通常不是我们想要的行为。</p>\n<p>***如果第二个参数传递一个空数组，代表efffect只会执行一次，相当于componentDidmount,return函数也只会在组件卸载的时候执行一次，相当于componentWillUnmount。</p>\n<p>***如果第二个参数数组中有一个或者多个状态值，那么只要有任意一个状态值发生变化，该effect都会再次执行。相当于componentDidUpdate。</p>\n<p>***useEffect是在组件状态改变之后，并且在组件layout和paint之后，也就是说组件出现在页面后再进行调用，useLayoutEffect是在组件状态改变后，但是在组件layout和paint之前，也就是在组件出现在页面之前进行调用。</p>\n<p>***useEffect是异步的，useLayoutEffect是同步的。useEffect不会堵塞主线程渲染。</p>\n\n        <h3 id=\"3.useRef\">\n            <a href='#3.useRef' class='header-anchor'>#</a>\n            <span>3.useRef</span>\n        </h3>\n    <pre class=\"prettyprint\"><code>function xxx(){\n  const inputRef = useRef(null);\n  useEffect(()=&amp;gt;{\n      inputRef.current.value = &#039;hello&#039;\n  },[])\n  return (\n      &amp;lt;input type=&quot;text&quot; ref={inputRef} /&amp;gt;\n  )\n}</code></pre><p>useRef 接收一个初始值，返回一个可变的ref对象，ref.current指向初始化的值。它可以指向别的值。<br>由于是函数组件，this不再指向这个组件，所以要达到class组件中实例变量的效果，可以通过useRef来实现。<br>如果你的 effect 返回一个函数，React 将会在执行清除操作时调用它：<br>为什么 effect 的清除阶段在每次重新渲染时都会执行，而不是只在卸载组件的时候执行一次。让我们看一个实际的例子，看看为什么这个设计可以帮助我们创建 bug 更少的组件。</p>\n\n        <h3 id=\"4.useContext\">\n            <a href='#4.useContext' class='header-anchor'>#</a>\n            <span>4.useContext</span>\n        </h3>\n    <p>useContext的参数必须是context本身；<br>设置context , const ThemContext = React.createContext(themes.light);<br>const value = useContext(MyContext);<br>因为没有static的限制，同一个组件中可以使用多个useContext。也就是说，可以使用多个上层组件传递来的数据。</p>\n\n        <h3 id=\"5.useReducer\">\n            <a href='#5.useReducer' class='header-anchor'>#</a>\n            <span>5.useReducer</span>\n        </h3>\n    <p>提到reducer，首先想到的应该是redux中的reducer。useReducer这个hook与redux中的reducer有所相似又有所不同。可以查看demo中的useReducer。<br>const [state, dispatch] = useReducer(reducer,initialState);<br>要预先写好reducer。<br>dipatch({type:&#39;ADD&#39;});<br>与redux中的reducer有所不同的是，useReducer中的reducer是独立的。如果有多个组件使用到了同一个reducer，那么它们之间的状态是独立的。相较于redux的全局共享状态，它还依赖于react-redux提供的Provider组件。<br>所以是不是突然想到了第四点中的Context，它提供了Provider。如果能配合useReducer，就可以实现全局状态共享了？确实如此！</p>\n\n        <h3 id=\"6.useImperativeHandle\">\n            <a href='#6.useImperativeHandle' class='header-anchor'>#</a>\n            <span>6.useImperativeHandle</span>\n        </h3>\n    <p>useImperativeHandle这个hook是ref的另一种写法。现在通过这个hook可以在子组件中暴露一些API供父组件调用。而父组件是不能直接操作子组件的dom元素的。</p>\n\n        <h3 id=\"7.useCallback\">\n            <a href='#7.useCallback' class='header-anchor'>#</a>\n            <span>7.useCallback</span>\n        </h3>\n    <p>父组件通过props传给子组件一个函数，这个函数用到父组件中的state,如果state改变的时候， memo子组件不会检测到属性的变化，useCallback就是为了解决这一问题，它缓存了一个函数，并接受一系列依赖项，返回一个函数，如果依赖项变化，函数变化。</p>\n<pre class=\"prettyprint\"><code>const handleChange =useCallback (()=&amp;gt;{\n        setResult(count + 1);  //count为父组件的一个state\n},[count])\n//子组件\n&amp;lt;Children  onChange={handleChange} /&amp;gt;</code></pre>\n        <h3 id=\"8.useMemo\">\n            <a href='#8.useMemo' class='header-anchor'>#</a>\n            <span>8.useMemo</span>\n        </h3>\n    <p>useMomo用来缓存一个复杂的计算值，useCallback(fn,deps)等价于useMomo(()=&gt;fn,deps)。如果通过一个输入得到一个值需要经过复杂的计算，那么下次同样的输入再进行一遍同样复杂的计算是没有必要的。这就是useMemo的意义。<br>const result = useMemo(()=&gt;computedExpensiveValue(40),[count]);<br>const result = computedExpensiveValue(40);<br>重新计算result的时候，如果count值没变，就直接从缓存里面读取，避免性能消耗。</p>\n<p>9.useDebugValue</p>\n<p>通常来说你不需要它。它只会存在于自定义的hooks中用来标志一个自定义的hooks。当在chrome中打开react扩展时候，如果一个组件使用到了自定义的hooks，并且该hooks使用到了useDebugValue，那么该组件下方会显示useDebugValue传入的参数。</p>\n<pre class=\"prettyprint\"><code>  function useUserInfo() {\n    // ...\n    useDebugValue(&#039;use-user-info&#039;);\n    return userInfo;\n  }\n</code></pre>"},{"context":[{"title":"大前端","link":"javascript:void(0)"},{"title":"vue","link":"javascript:void(0)"},{"title":"vue工程","link":"/front/vue/project.html"}],"content":"\n        <h1 id=\"vue工程\">\n            <a href='#vue工程' class='header-anchor'>#</a>\n            <span>vue工程</span>\n        </h1>\n    "},{"context":[{"title":"大前端","link":"javascript:void(0)"},{"title":"vue","link":"javascript:void(0)"},{"title":"vue基础语法","link":"/front/vue/vuebase.html"}],"content":"\n        <h3 id=\"vue语法\">\n            <a href='#vue语法' class='header-anchor'>#</a>\n            <span>vue语法</span>\n        </h3>\n    <p>#模板中显示数据<br>{{}}，v-text=&quot;&quot;,v-html=&quot;字符串中包含标签将作为html解析&quot;</p>\n<p>#绑定事件<br>v-on:click=&quot;handleClick&quot;  @click=&quot;handleClick&quot;</p>\n<p>#属性绑定<br>v-bind:title=&quot;title&quot;  , :title=&quot;&quot;</p>\n<p>#双向数据绑定<br>v-model=&quot;&quot;</p>\n<p>#vue中的计算属性和侦听器</p>\n<pre class=\"prettyprint\"><code>computed:{\n    fullName: function(){\n        return this.firstName+&#039; &#039;+this.lastName;\n    }\n}\nwatch:{\n    fullName:function(){\n        监听fullName,如果fullName发生变化，就做出相应变化；\n    }\n}</code></pre><p>#vue中条件判断和循环</p>\n<pre class=\"prettyprint\"><code>v-if=&quot;ture&quot; ， v-show=&quot;true&quot;\n&amp;lt;li v-for=&quot;item of list&quot;&amp;gt;{{item}}&amp;lt;/li&amp;gt;</code></pre><p>#vue中样式和class的绑定<br>style=&quot;原生的样式&quot;<br>:style=&quot;{一个样式的对象，数据可以来自vue实例中的成员变量}&quot;<br>:class=&quot;{&#39;active&#39;: true}&quot; 绑定单个class,并判断是否生效<br>:class=&quot;[{&#39;active&#39;: true},{&#39;isShow&#39;:true}]&quot;<br>#vue中数据传递<br>1.父组件向子组件传递数据props</p>\n<p>父组件将值绑定到子组件属相上:data= &quot;data&quot;<br>子组件</p>\n<pre class=\"prettyprint\"><code>export default {\n    props: [&#039;logo&#039;]\n}\n使用的时候，直接{{logo}}\n```\n2.子组件向父组件传值\n```\n//子组件\n&amp;lt;input @change=&quot;setUser&quot; /&amp;gt;\ndata(){\n    return {\n        username:&#039;&#039;\n    }\n},\nmethods:{\n    setUser: function(){\n        this.$emit(&#039;transferUser&#039;,this.username);\n    }\n}\n//父组件\n&amp;lt;子组件 @transferUser=&quot;getUser&quot;&amp;gt;&amp;lt;/子组件&amp;gt;\nmethods:{\n    getUser(username){\n        this.user=username\n    }\n}\n```\n\n\n\n\n### Vue-cli\nvue工程的脚手架工具\n#全局安装vue-cli\nnpm install -g @vue/cli  @vue/cli-service-global\\\n\n#创建基于webpack模板的新项目\nvue create todolist\n\n#到应用目录下启动项目\nnpm run serve\n\n### 集成element-ui组件库\n\n#安装组件库\ncnpm install -S element-ui\n\n#在main.js中引入，全局可用\nimport ElementUI from &#039;element-ui&#039;\nimport  &#039;element-ui/lib/theme-chalk/index.css&#039;\nVue.use(ElementUI);\n\n\n### vue-router\n\nvue官方路由解决方案\n\n#组件标签\n```\n&amp;lt;div&amp;gt;\n    &amp;lt;router-link to=&quot;/foo&quot;&amp;gt;&amp;lt;/router-link&amp;gt;\n    //匹配到的组件将渲染到这里\n    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;\n&amp;lt;/div&amp;gt;\n```\n#定义路由\n```\nconst routes = [\n    {path:&#039;/foo&#039;,component: Foo},\n    {path:&#039;bar&#039;,component: Bar}\n]\n```\n\n#创建router实例\n```\nconst router = new VueRouter({\n    routes\n})\n```\n#创建和挂载根实例\n```\nconst app = new Vue({\n    router\n}).$mount(&quot;#app&quot;);\n```\n#动态路由传参\n```\nroutes: [\n    {path: &#039;/user/:id&#039;,component: User}\n]\n```\n\n#监测路由变化\n```\nwatch: {\n    &#039;$route&#039;(to,from){\n        //对路由变化做出回应\n    }\n}\n\n```\n#使用路由的一些方法\n\n//获取参数\nthis.$route.params.username;\n//后退\nthis.$router.go(-1);\n//跳转到新的路由\nthis.$router.push(&quot;/&quot;);\nthis.$router 和 router 使用起来完全一样。我们使用 this.$router 的原因是我们并不想在每个独立需要封装路由的组件中都导入路由\n\n#2.2中引入了导航守卫beforeRouteUpdate\n```\nconst User = {\n    template: &#039;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&#039;,\n    beforeRouterUpdate(to,from,next){\n        //执行响应操作，不要忘记回调next();\n    }\n}\n```\n#匹配404\n将这个路由匹配放到最后面\n```\n{\n    path: &#039;*&#039;,//会匹配所有路径\n    component: 404\n}\n```\n当使用通配符时，$route.params内会自动添加一个名为 pathMatch 参数，它包含了URL通过通配符匹配到的东西\nthis.$route.params.pathMatch;\n\n#嵌套路由\n```\nconst User = {\n  template: `\n    &amp;lt;div class=&quot;user&quot;&amp;gt;\n    &amp;lt;h2&amp;gt;User {{ $route.params.id }}&amp;lt;/h2&amp;gt;\n    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;\n    &amp;lt;/div&amp;gt;`\n}\nconst router = new VueRouter({\n  routes: [\n    {\n      path: &#039;/user/:id&#039;, component: User,\n      children: [\n        {\n          // 当 /user/:id/profile 匹配成功，\n          // UserProfile 会被渲染在 User 的 &amp;lt;router-view&amp;gt; 中\n          path: &#039;profile&#039;,\n          component: UserProfile\n        },\n        {\n          // 当 /user/:id/posts 匹配成功\n          // UserPosts 会被渲染在 User 的 &amp;lt;router-view&amp;gt; 中\n          path: &#039;posts&#039;,\n          component: UserPosts\n        }\n      ]\n    }\n  ]\n})\n```\n基于上面的配置，当你访问 /user/foo 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由：\n\n```\nconst router = new VueRouter({\n  routes: [\n    {\n      path: &#039;/user/:id&#039;, component: User,\n      children: [\n        // 当 /user/:id 匹配成功，\n        // UserHome 会被渲染在 User 的 &amp;lt;router-view&amp;gt; 中\n        { path: &#039;&#039;, component: UserHome },\n\n        // ...其他子路由\n      ]\n    }\n  ]\n})\n```\n\n#命名路由\n```\nconst router = new VueRouter({\n    routes:[\n        {\n            path:&#039;/user/:userId&#039;,\n            name:&#039;user&#039;,\n            component: User\n         }\n    ]\n})\n```\n使用时\n```\n&amp;lt;router-link to=&quot;{name:&#039;user&#039;,params:{userId:123}}&quot;&amp;gt;user&amp;lt;/router-link&amp;gt;\nrouter.push({name:&#039;user&#039;,params:{userId:123}});\n```\n#命名视图\n同一个url可以在一个页面上显示多个视图，只要对应好视图名字，未命名的视图则是default\n```\n&amp;lt;div&amp;gt;\n    &amp;lt;router-view class=&quot;view one&quot;&amp;gt;&amp;lt;/router-view&amp;gt;\n    &amp;lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&amp;gt;&amp;lt;/router-view&amp;gt;\n    &amp;lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&amp;gt;&amp;lt;/router-view&amp;gt;\n&amp;lt;/div&amp;gt;\nconst router = new VueRouter({\n  routes: [\n    {\n      path: &#039;/&#039;,\n      components: {\n        default: Foo,\n        a: Bar,\n        b: Baz\n      }\n    }\n  ]\n})\n\n```\n#重定向和别名\n```\nconst router = new VueRouter({\n    routes:[\n        {path:&#039;/a&#039;,redirect:&#039;/b&#039;}  \n        或着 {path:&#039;&#039;,redirect:{name:&#039;foo&#039;}}\n        或者 {path:&#039;/a&#039;,redirect: to=&amp;gt;{\n            //方法接收目标路由作为参数\n            //return 重定向字符串路径或者路径对象\n       }}\n    ]\n})\n\n```\n#别名\n给‘/a’匹配别名‘/b’，则访问‘/b’和访问‘/a’是一样的\n```\nconst router = new VueRouter({\n    routes:[\n        {path: &#039;/a&#039;,component: A, alias: &#039;/b&#039;}\n    ]\n})\n//alias 别名\n```\n#路由组件传参\n通过props将组件和路由解耦\n如果 props 被设置为 true，route.params 将会被设置为组件属性\n```\nconst User = {\n  props: [&#039;id&#039;],\n  template: &#039;&amp;lt;div&amp;gt;User {{ id }}&amp;lt;/div&amp;gt;&#039;\n}\nconst router = new VueRouter({\n  routes: [\n    { path: &#039;/user/:id&#039;, component: User, props: true },\n\n    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：\n    {\n      path: &#039;/user/:id&#039;,\n      components: { default: User, sidebar: Sidebar },\n      props: { default: true, sidebar: false }\n    }\n  ]\n})\n```\n基本都是通过props传递\n\nvue-router默认使用hash路由，不需要后端支持，可用浏览器直接打开，\nhistory路由需要后端环境支持\n使用history路由，后端nginx支持\nnginx\n```\nlocation / {\n  try_files $uri $uri/ /index.html;\n}\n```</code></pre>"},{"context":[{"title":"数据库","link":"javascript:void(0)"},{"title":"mysql","link":"/database/mysql.html"}],"content":"\n        <h1 id=\"mysql\">\n            <a href='#mysql' class='header-anchor'>#</a>\n            <span>mysql</span>\n        </h1>\n    "},{"context":[{"title":"java","link":"javascript:void(0)"},{"title":"mybatis","link":"/java/mybatis.html"}],"content":"\n        <h3 id=\"mybatis\">\n            <a href='#mybatis' class='header-anchor'>#</a>\n            <span>mybatis</span>\n        </h3>\n    <p>####</p>\n"},{"context":[{"title":"java","link":"javascript:void(0)"},{"title":"SpringBoot","link":"/java/springboot.html"}],"content":"\n        <h3 id=\"spring优缺点\">\n            <a href='#spring优缺点' class='header-anchor'>#</a>\n            <span>spring优缺点</span>\n        </h3>\n    <p>优点: 轻量化实现EJB。<br>缺点：配置太繁琐<br>SpringBoot简化了繁琐的配置，使开发的精力集中于业务逻辑代码的编写。<br>SpringBoot不是对Spring功能的增强，而是提供了一个快速使用Spring的方式。</p>\n\n        <h3 id=\"SpringBoot环境搭建\">\n            <a href='#SpringBoot环境搭建' class='header-anchor'>#</a>\n            <span>SpringBoot环境搭建</span>\n        </h3>\n    <p>创建一个module类型的maven工程。</p>\n<p>pom.xml中配置<br>SpringBoot要求，项目要继承SpringBoot的起步依赖spring-boot-starter-parent</p>\n<pre class=\"prettyprint\"><code>  &amp;lt;parent&amp;gt;\n    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;\n    &amp;lt;version&amp;gt;2.0.1.RELEASE&amp;lt;/version&amp;gt;\n  &amp;lt;/parent&amp;gt;</code></pre><p>SpringBoot要继承SpringMVC进行Controller的开发，所以项目要导入web的启动依赖：</p>\n<pre class=\"prettyprint\"><code>&amp;lt;dependencies&amp;gt;\n  &amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;\n  &amp;lt;/dependency&amp;gt;\n&amp;lt;/dependencies&amp;gt;\n</code></pre><p>创建引导类<br>在java中建com.scxgo包，新建文件作为入口文件，例如 MySpringBootApplication类</p>\n<pre class=\"prettyprint\"><code>//此注解声明类是一个SpringBoot的引导类\n@SpringBootApplication\npublic class MySpringBootApplication{\n  //程序入口\n\n  public static void main(String[] args){\n    SpringApplication.run(MySpringBootApplication.class);\n  }\n}</code></pre><p>创建controller<br>创建controller包，建类，类上面加注解@Controller,方法上加@RequestMapping(&quot;/&quot;),@ResponseBody<br>tomcat跑在8080端口<br>IDEA可以自动初始化一个springboot工程<br>创建新工程的时候选择Spring Initializr就可以了。</p>\n\n        <h3 id=\"SpringBoot工程热部署\">\n            <a href='#SpringBoot工程热部署' class='header-anchor'>#</a>\n            <span>SpringBoot工程热部署</span>\n        </h3>\n    <p>pom.xml中需添加依赖<br><dependency><br>  <groupId>org.springframework.boot</groupId><br>  <artifactId>spring-boot-devtools</artifactId><br></dependency><br>注意：热部署失败的原因是 IDEA默认情况下不自动编译，需要对IDEA进行自动编译设置<br>file-settings-Compiler-build project automatically</p>\n<p>shift+ctrl+alt+/,选择Registry-compiler.automake.allow.when.app.running 勾选</p>\n\n        <h3 id=\"SpringBoot配置文件\">\n            <a href='#SpringBoot配置文件' class='header-anchor'>#</a>\n            <span>SpringBoot配置文件</span>\n        </h3>\n    <p>SpringBoot是基于约定的，很多配置都有默认值，需要增加或者覆盖原有配置，可以使用<br>resources文件加下application.properties 或者 application.yml(或者application.yaml)进行配置。（命名规则为application<em>.properties或者application</em>.yml）<br>yml格式</p>\n<pre class=\"prettyprint\"><code>//普通数据的配置\nname: zhangsan  //值前面一定要有个空格\n\n//对象的配置\nperson:\n  name: zhangsan //缩进是自由的，但是要保证每层的缩进是一样的\n  age: 18\n  addr: suizhou\n\n//行内对象配置(用的少)\nperson: {name: zhangsan, age: 18, addr: suizhou}\n\n//配置数组、集合\ncity:\n  - beijing\n  - shanghai\n  - suizhou\n  - shenzhen\n\n//行内数组、集合\ncity: [beijing,shanghai,suizhou,shenzhen]\n\n//配置数组、集合（对象数据）\nstudent:\n  - name: tom\n    age: 18\n    addr: beijing\n  - name: lily\n    age: 25\n    addr: suizhou\n//行内\nstudent: [{name: tom,age: 18,addr:beijing},{name:lily,age:25,addr: suizhou}]</code></pre><p>配置文件与配置类的属性映射<br>有两种方式<br>1.@Value 注解可以将配置文件中的值映射到一个Spring管理的Bean字段上。<br>application.yml中</p>\n<pre class=\"prettyprint\"><code>person:\n  name: zhangsan\n  age: 18\n</code></pre><p>Bean代码如下：</p>\n<pre class=\"prettyprint\"><code>  @Controller\n  public class QuicStartController{\n    @Value(&quot;${person.name}&quot;)\n    private String name;\n    @Value(&quot;${person.age}&quot;)\n    private Integer age;\n  }</code></pre><p>2.@ConfigurationProperties(prefix=&quot;配置文件中key的前缀&quot;)，该注解可以将文件中的配置自动与实体进行映射<br>application.yml中</p>\n<pre class=\"prettyprint\"><code>person:\n  name: zhangsan\n  age: 18</code></pre><p>Bean中</p>\n<pre class=\"prettyprint\"><code>@Controller\n@ConfigurationProperties(prefix=&quot;person&quot;)\npulic class QuikStartController{\n  private String name;\n  private String age;\n  @RequestMapping(&quot;/quik&quot;)\n  @ResponseBody\n  public String quik(){\n    return &quot;my name&quot;+&quot; is &quot;+name;\n  }\n}</code></pre>\n        <h3 id=\"SpringBoot集成\">\n            <a href='#SpringBoot集成' class='header-anchor'>#</a>\n            <span>SpringBoot集成</span>\n        </h3>\n    <p>一.整合mybatis<br>添加mybatis起步依赖</p>\n<pre class=\"prettyprint\"><code>  &amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;artifactId&amp;gt;\n    &amp;lt;version&amp;gt;1.1.1&amp;lt;/version&amp;gt;\n  &amp;lt;/dependency&amp;gt;</code></pre><p>导入数据库坐标（mysql连接驱动）</p>\n<pre class=\"prettyprint\"><code>&amp;lt;dependency&amp;gt;\n  &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;\n  &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;\n&amp;lt;/dependency&amp;gt;</code></pre><p>添加数据库连接信息</p>\n<pre class=\"prettyprint\"><code>spring:\n  datasource:\n    driverClassName: com.mysql.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8\n    username: root\n    password: root</code></pre><p>插入数据(建表sql语句)</p>\n<pre class=\"prettyprint\"><code>//建表语句\n  DROP TABLE IF EXISTS `user`;\n  CREATE TABLE `user`(\n      `id` int(11) NOT NULL AUTO_INCREMENT,\n      `username` varchar(50) DEFAULT NULL,\n      `password` varchar(50)  DEFAUL NULL,\n      `name` varchar(50) DEFAULT NULL,\n      PRIVATE KEY (`id`)\n  ) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;\n\n//插入语句\n  INSERT INTO `user` VALUES (&#039;1&#039;,&#039;zhangsan&#039;,&#039;123&#039;,&#039;张三&#039;);\n  INSERT INTO `user` VALUES (&#039;2&#039;,&#039;lisi&#039;,&#039;123&#039;,&#039;李四&#039;);</code></pre><p>创建实体<br>java内包里见domain包，创建文件User.java建实体类</p>\n<pre class=\"prettyprint\"><code>public class User{\n  private Integer id;\n  private String username;\n  private String password;\n  private String name;\n  //后面为getter，setter方法\n}</code></pre><p>resources文件夹下创建mapper包，里面配置UserMapper.xml</p>\n<pre class=\"prettyprint\"><code>&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;\n&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt;\n\n&amp;lt;mapper namespace=&quot;com.scxgo.mapper.UserMapper&quot;&amp;gt;\n  &amp;lt;select id=&quot;queryUserList&quot; resultType=&quot;user&quot;&amp;gt;\n    select * from user\n  &amp;lt;/select&amp;gt;\n&amp;lt;/mapper&amp;gt;</code></pre><p>java内包中建mapper包，建UserMapper.java文件，写接口</p>\n<pre class=\"prettyprint\"><code>  @Mapper\n  public interface UserMapper{\n    public List&amp;lt;User&amp;gt; queryUserList();\n  }</code></pre><p>在application.yml中配置mybatis信息</p>\n<pre class=\"prettyprint\"><code>mybatis:\n  type-aliases-package: com.scxgo.domain  #pojo别名扫描包\n  mapper-locations: classpath:mapper/*Mapper.xml  #加载mybatis映射文件</code></pre><p>写个controller测试下<br>建包controller</p>\n<pre class=\"prettyprint\"><code>  @Controller\n  public class MybatisController{\n    @Autowired\n    private  UserMapper userMapper;\n    @RequestMapping(&quot;/query&quot;)\n    @ResponseBody\n    public List&amp;lt;User&amp;gt; queryUserList(){\n      List&amp;lt;User&amp;gt; users = userMapper.queryUserList();\n      return users;\n    }\n  }</code></pre>\n        <h3 id=\"集成Junit\">\n            <a href='#集成Junit' class='header-anchor'>#</a>\n            <span>集成Junit</span>\n        </h3>\n    <p>添加Junit起步依赖</p>\n<pre class=\"prettyprint\"><code>  &amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;org.springframwork.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;\n    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;\n  &amp;lt;/dependency&amp;gt;</code></pre><p>编写测试类</p>\n<pre class=\"prettyprint\"><code>@RunWith(SpringRunner.class)\n@SpringBootTest(classes=MyApplication.class) //引导类的字节码\npublic class MyTest{\n  @Test\n  public void test(){\n    ...\n  }\n}</code></pre>\n        <h3 id=\"Spring-Data-JPA集成\">\n            <a href='#Spring-Data-JPA集成' class='header-anchor'>#</a>\n            <span>Spring Data JPA集成</span>\n        </h3>\n    <p>添加起步依赖</p>\n<pre class=\"prettyprint\"><code>&amp;lt;dependency&amp;gt;\n  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;\n&amp;lt;/dependency&amp;gt;</code></pre><p>添加数据库驱动依赖</p>\n<pre class=\"prettyprint\"><code>&amp;lt;dependency&amp;gt;\n  &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;\n  &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;\n&amp;lt;/dependency&amp;gt;</code></pre><p>在application.yml中配置数据库和jpa相关属性</p>\n<pre class=\"prettyprint\"><code>#DB Configuration\nspring:\n  datasource:\n    driverClassName: com.mysql.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8\n    username: root\n    password: root\n#JPA Configuration\n  jpa:\n    datasource: mysql\n    show-sql: true\n    generate-ddl: true\n    hibernate:\n      ddl-auto: update\n      naming_strategy: org.hibernate.cfg.ImprovedNamingStrategy\n</code></pre><p>在domain文件中创建实体类</p>\n<pre class=\"prettyprint\"><code>@Entiry\npublic class User{\n  @Id\n  @GeneratedValue(strategy=GenerationType.IDENTITY)\n  private Long id;\n  private String username;\n  private String password;\n  private name;\n}</code></pre><p>创建repository包，建UserRepository类</p>\n<pre class=\"prettyprint\"><code>//User为实体类名，Long是实体类中id的数据类型\n@Repository\npublic interface UserRepository extends JpaRepository&amp;lt;User,Long&amp;gt;{\n  public List&amp;lt;User&amp;gt; findAll();\n}</code></pre><p>创建实现类UserImpl</p>\n<pre class=\"prettyprint\"><code></code></pre>\n        <h3 id=\"SpringBoot集成Redis\">\n            <a href='#SpringBoot集成Redis' class='header-anchor'>#</a>\n            <span>SpringBoot集成Redis</span>\n        </h3>\n    <p>安装redis服务器并启动<br>添加redis起步依赖</p>\n<pre class=\"prettyprint\"><code>  &amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;\n  &amp;lt;/dependency&amp;gt;</code></pre><p>在application.yml中注入redis连接信息</p>\n<pre class=\"prettyprint\"><code>spring:\n  redis:\n    host: 127.0.0.1\n    port: 6379</code></pre><p>测试redis服务</p>\n<pre class=\"prettyprint\"><code>@RunWith(&quot;SpringRunner&quot;)\n@SpringBootTest(classes=MySpringBootApplication.class)\npublic class RedisTest{\n  @Autowired\n  private RedisTemplate&amp;lt;String,String&amp;gt; redisTemplate;\n  @Autowired\n  private UserRepository userRepository;\n  @Test\n  public void test(){\n    //1.从redis中去获得需要的数据，一般是json字符串格式\n    String userListJson = redisTemplate.boundValueOps(&quot;user.findAll&quot;).get();\n    //2.判断redis中是否存在数据\n    if(null == userListJson){\n      //3.不存在，则从数据库中查询\n      List&amp;lt;User&amp;gt; all = userRepository.findAll();\n      //4.将查出的数据存储到redis缓存中\n      //存之前先要把list转换成string，此时可是有spring自带的jackson来做\n      ObjectMapper objectMapper = new ObjectMapper();\n      userListJson = objectMapper.writeValueAsString(all);\n      redisTemplate.boundValueOps(&quot;user.findAll&quot;).set(userListJson);\n    }\n\n  }\n}\n</code></pre>\n        <h3 id=\"日志使用\">\n            <a href='#日志使用' class='header-anchor'>#</a>\n            <span>日志使用</span>\n        </h3>\n    <p>选择slf4j和Logback框架<br>日志级别 error warn info debug trace<br>默认级别为info，info及其以上级别会触发日志记录<br>在类中使用Log<br>1.非注解方法<br>private final Logger logger =  loggerFactory.getLogger(LoggerTest.class);<br>//LoggerTest为当前使用日志的类<br>logger.info(&#39;输出信息&#39;);</p>\n<p>2.使用注解@Slf4j,需要用到lombok小工具。</p>\n<pre class=\"prettyprint\"><code>//pom.xml中配置\n&amp;lt;dependency&amp;gt;\n  &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;\n  &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;\n&amp;lt;/dependency&amp;gt;\n//类中注解用\nlog.info(&quot;输出信息&quot;);\n//日志中输出变量的方法\nlog.info(&quot;name:&quot;+name);\n或者\nlog.info(&quot;name:{}&quot;,name);</code></pre><p>Logback的配置（application.yml中配置，可区分info和erro,xml可配置定期产生日志）</p>\n<p>logging:<br>  pattern:<br>    console: &quot;%d - %msg%n&quot; //日志格式，输出时间-内容-换行<br>    file: /var/log/tomcat/sell.log //输出日志的文件<br>    level: info  //输出日志级别（info及其级别以上的都会被输出）</p>\n<p><code></code></p>\n"},{"context":[{"title":"java","link":"javascript:void(0)"},{"title":"annotation","link":"/java/annotation.html"}],"content":"\n        <h3 id=\"IOC容器注解\">\n            <a href='#IOC容器注解' class='header-anchor'>#</a>\n            <span>IOC容器注解</span>\n        </h3>\n    <p>@Component<br>  作用<br>    将当前对象放存入Spring容器。<br>  属性<br>    value: 用于指定bean的id,不指定，则默认为当前类名，且首字母小写。<br>  类似@Component注解<br>@Controller<br>@Service<br>@Repository<br>  作用<br>    同Component注解一样，只是对三层代码类的注解</p>\n<p>@Bean<br>  作用<br>    作用在方法上，将方法的返回值作为bean对象放入spring容器。<br>  属性<br>    name: 用于指定bean的id,不写时，默认值为当前方法名称。<br>  细节<br>    当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。查找的方式和Autowired注解的作用是一样的。</p>\n\n        <h3 id=\"配置相关注解\">\n            <a href='#配置相关注解' class='header-anchor'>#</a>\n            <span>配置相关注解</span>\n        </h3>\n    <p>@Configuration<br>  作用<br>    指定当前类是一个配置类</p>\n<p>@Import<br>  作用<br>    将一个类包含到另一个类，通常是配置类（分配置引入到主配置中）<br>  属性<br>    value: 被引入类的字节码<br>@ComponentScan<br>  作用<br>    用于通过注解指定spring在创建容器时要扫描的包。<br>  属性<br>    value: 它和basePackages的作用是一样的，都是用于制动创建容器时要扫描的包。</p>\n<p>@PropertySource(&quot;classpath:config/spring/.jdbcConfig.properties&quot;)<br>  通常配合@Value使用，不指定配置文件的时候，默认是主配置文件（application.properties或者application.yml）<br>  作用<br>    用于指定properties文件的路径。<br>  属性<br>    value: 指定文件的名称和路径<br>    关键字: classpath,表示类路径下</p>\n<p>@ConfigurationProperties(prefix=&quot;spring&quot;)<br>  作用<br>    将application.yml中的字段自动映射到注解类的成员变量<br>  属性<br>    prefix: 配置文件下字段spring对象下的字段作为映射对象</p>\n\n        <h3 id=\"注入数据\">\n            <a href='#注入数据' class='header-anchor'>#</a>\n            <span>注入数据</span>\n        </h3>\n    <p>@Autowired<br>  作用<br>    自动按照类型注入，只要容器中有唯一的一个bean对象类型和注入变量的类型匹配，就可以注入成功。<br>    如果容器没有类型匹配则报错。<br>    如果容器中有多个类型与之匹配，会报错，此时需要用到Qualifier注解。<br>  位置<br>    可以是变量上，也可以是方法上<br>  @Qualifier(value=&quot;bean的id&quot;)  (本意为限定符，修饰词，合格者)<br>  作用<br>    在按照类型注入的基础之上再按照名称注入，它在给类成员注入时不能单独使用（Autowired注解的类型有多个时使用），但是在给方法参数注入时可以单独使用。<br>  属性<br>    value:被注入的bean的id<br>  注：Qualifier在个方法参数注解的时候可以独立使用，value值为bean的id</p>\n<pre class=\"prettyprint\"><code>    public QueryRunner createQueryRunner(@Qualifier(&#039;ds1&#039;) DataSource dataSource){\n      //有两个返回DataSource类型值的方法被@Bean注解了，此时需要通过id来识别到底是用哪个作为参数\n    }\n</code></pre><p>@Resource(name=&quot;bean的id&quot;)<br>  作用<br>    直接按照bean的id注入，可以独立使用（取代Autowired和Qualifier一起使用的情况）。<br>  属性<br>    name: 被注入的bean的id</p>\n<p>  注意：以上三个注入只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现，另外，集合类型的注入只能通过XML来实现。</p>\n<p>@Value<br>  作用<br>    用于注入基本类型和String类型的数据<br>  属性<br>    value: 用于指定数据的值，它可以使用spring的SpEl（el表达式，即${表达式}）</p>\n\n        <h3 id=\"用于改变作用范围的注解\">\n            <a href='#用于改变作用范围的注解' class='header-anchor'>#</a>\n            <span>用于改变作用范围的注解</span>\n        </h3>\n    <p>@Scope<br>  作用<br>    用于指定bean的作用范围。<br>  属性<br>    value: 指定范围的取值，常用值为 singleton prototype,即单例和多例，不写的时候默认为单例。<br>    <code>@Scope(&amp;quot;prototype&amp;quot;)//多实例，IOC容器启动创建的时候，并不会创建对象放在容器在容器当中，当你需要的时候，需要从容器当中取该对象的时候，就会创建。\n    @Scope(&amp;quot;singleton&amp;quot;)//单实例 IOC容器启动的时候就会调用方法创建对象，以后每次获取\n    @Scope(&amp;quot;request&amp;quot;)//同一个请求创建一个实例\n    @Scope(&amp;quot;session&amp;quot;)//同一个session创建一个实例</code></p>\n\n        <h3 id=\"生命周期相关注解\">\n            <a href='#生命周期相关注解' class='header-anchor'>#</a>\n            <span>生命周期相关注解</span>\n        </h3>\n    <p>@PreDestroy<br>  作用<br>    用在方法上，用于指定该方法为销毁方法。<br>@PostConstruct<br>  作用<br>    用在方法上，用于指定该方法为初始化方法。<br>注：多例对象的销毁spring不负责，所以单例对象销毁之前会调用销毁方法</p>\n\n        <h3 id=\"请求类中的注解\">\n            <a href='#请求类中的注解' class='header-anchor'>#</a>\n            <span>请求类中的注解</span>\n        </h3>\n    <p>请求类一般用@Controller或者@RestController注解<br>类中的方法上的注解<br>@RequestMapping(&quot;/quik&quot;)<br>@ResponseBody</p>\n\n        <h3 id=\"测试类中的注解\">\n            <a href='#测试类中的注解' class='header-anchor'>#</a>\n            <span>测试类中的注解</span>\n        </h3>\n    <p>测试类上的注解<br>@RunWith(SpringRunner.class)<br>@SpringBootTest(classes = MySpringBootApplication.class) //引导类的字节码<br>方法上的注解<br>@Test</p>\n<p>###实体类中的注解<br>@Entity  //注解在类上，表示设个类是实体类<br>@DynamicUpdate //注解在类上，更新时间字段在该条数据更新的时候更新为当前时间<br>注解在成员变量上的注解<br>@Id  表明该字段为映射数据表的主键<br>@GeneratedValue(strategy=GenerationType.IDENTITY) //mysql数据库自增字段的策略</p>\n<p>配置lombok<br><dependency><br>  <groupId>org.projectlombok</groupId><br>  <artifactId>lombok</artifactId><br></dependency><br>安装lombok插件。<br>然后在类上使用@Data注解。<br>这样就不用写getter,setter, toString方法了。</p>\n"},{"context":[{"title":"java","link":"javascript:void(0)"},{"title":"api","link":"/java/api.html"}],"content":"\n        <h3 id=\"Optional\">\n            <a href='#Optional' class='header-anchor'>#</a>\n            <span>Optional</span>\n        </h3>\n    <p>java8中引入，解决对象可能有值，也可能为空的冗余判断</p>\n<p>通过静态方法创建</p>\n<pre class=\"prettyprint\"><code>empty()\n  返回一个空的Optional对象\nof()\nofNullable()\n  我们都是通过of和ofNullable方法来为Optional中的value赋值，他们也是有区别的\n    of方法的特点\n      1.当value值为空时，会报NullPointerException异常；\n      2.当value值不为空时，正常构造Optional对象；\n    ofNullable方法特点\n      如果value值为空，会返回empty方法构建的Optional对象（即Optional中value为空的Optional对象），也就是说ofNullable支持空值的创建；      \nget()\n  返回Optional中的value值\n\nisPresent和ifPresent\n  isPresent是判断Optional中的value是否为空，不为空返回true，为空返回false；\n  ifPresent方法是Optional中value不为空的情况下做的一些操作；\n  例如：\n  Optional.ofNullable(user).ifPresent(System.out.println(&quot;不为空&quot;))\n\norElse()、 orElseGet() 和 orElseThrow()\n  都是处理Optional值为空的情况，如果传入value为空，进行操作；\n  orElse和orElse的区别在于，如果value不为空，orElse中的操作仍然要执行，orElseGet则不会。\n  orElseThrow()是在value为空的时候抛出异常；</code></pre>"},{"context":[{"title":"微信小程序","link":"javascript:void(0)"},{"title":"微信小程序","link":"/wechat/wechat.html"}],"content":"\n        <h3 id=\"准备工作\">\n            <a href='#准备工作' class='header-anchor'>#</a>\n            <span>准备工作</span>\n        </h3>\n    <p>1.进入微信公众平台官网<br>  <a href=\"http://mp.weixin.qq.com\">http://mp.weixin.qq.com</a><br>  -注册账号（分为个人和企业，只能注册个人）<br>  -下载微信开发者工具(开发文档-工具-下载)<br>  -登录小程序上号后台获取appid</p>\n<p>给小程序设置苹方字体(只有苹果设备有效果)<br>font-family:&quot;PingFangSC-Thin&quot;;</p>\n<p>2.定义与引用组件<br>定义一个组件，跟page页面是一样的结构。<br>在引用该组件时，要在引用page的json配置文件中配置<br>{<br>  &quot;usingComponents&quot;:{<br>    &quot;icon&quot;:&quot;组件的路径&quot;<br>  }<br>}</p>\n<p>3.数据传递<br>父组件向子组件传递数据是实用properties<br>Component({<br>  properties:{<br>    属性名:{<br>      type: 属性类型（String,Boolean,Number 等）,<br>      value: 默认值,//可选<br>      observer:function(newVal,oldVal,changedPath){<br>        //可选</p>\n<pre class=\"prettyprint\"><code>  }\n}</code></pre><p>  }<br>})<br>组件中复用数据使用behavior<br>结构和组件一样，使用功能Behavior关键词定义<br>Behavior({<br>    properties:{<br>      //主要是将各组件中需要复用的数据放在这里<br>    }<br>})<br>组件中导入behavior组件，在组件中复用的时候加上<br>behaviors:[]</p>\n<p>4.页面生命周期函数<br>onLoad:funciton(){//页面加载,onLoad在onReady之前触发，且每次更新都会触发}<br>onReady:function(){//页面初次渲染完成}<br>onShow:function(){//页面显示}<br>onHide:function(){//页面隐藏}<br>onUnload:function(){//页面卸载}</p>\n<p>5.组件生命周期函数<br>create:function(){//组件实例进入页面节点树的时候执行，注意此时不能调用setData}<br>attached: funciton(){//组件实例进图页面节点树的时候执行,常用}<br>6.请求数据<br>wx.request({<br>    url,<br>    head,<br>    dataType:&quot;返回数据类型&quot;,<br>    method:&quot;GET&quot;,<br>    data:&quot;请求参数&quot;,<br>    success:function(result){},<br>    fail:function(result){},<br>    complete:function(){//接口调用结束后的回调函数，成功或失败都会执行}<br>  })</p>\n"},{"context":[{"title":"Bash脚本","link":"javascript:void(0)"},{"title":"简介","link":"/bash/introduce.html"}],"content":"\n        <h3 id=\"Bush简介\">\n            <a href='#Bush简介' class='header-anchor'>#</a>\n            <span>Bush简介</span>\n        </h3>\n    <p>Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应<br>Bash 是目前最常用的 Shell</p>\n<p>下面命令可以查看当前运行的Shell</p>\n<pre class=\"prettyprint\"><code>echo $SHELL</code></pre><p>下面命令可以查看当前的Linux系统安装的所有Shell</p>\n<pre class=\"prettyprint\"><code>cat /etc/shells</code></pre>"},{"context":[{"title":"git","link":"javascript:void(0)"},{"title":"git","link":"/git/git.html"}],"content":"\n        <h3 id=\"一.创建版本库（repository）\">\n            <a href='#一.创建版本库（repository）' class='header-anchor'>#</a>\n            <span>一.创建版本库（repository）</span>\n        </h3>\n    <p>  创建一个空目录，并初始化<br>  mkdir learngit<br>  cd learngit<br>  git init<br>  git init --bare //初始化一个纯版本目录，不带本地仓库</p>\n\n        <h3 id=\"二.把文件添加到版本库\">\n            <a href='#二.把文件添加到版本库' class='header-anchor'>#</a>\n            <span>二.把文件添加到版本库</span>\n        </h3>\n    <p>  建一个文件，并告诉git把文件添加到仓库<br>  touch readme.txt<br>  git add readme.txt  //文件添加到仓库<br>  git commit -m &#39;描述内容&#39; //把文件提交到git仓库</p>\n\n        <h3 id=\"三.时光穿梭机\">\n            <a href='#三.时光穿梭机' class='header-anchor'>#</a>\n            <span>三.时光穿梭机</span>\n        </h3>\n    <p>  1.版本回退<br>    git status //git会告诉我们是否有改动，改动是否提交，但不会告诉我们具体改动的地方<br>    git diff readme.txt //git会告诉你readme.txt文件里面具体被改动的地方<br>    每次修改文件或者文件夹后需要做两个操作，<br>    git add  (文件或者文件夹)<br>    git commit -m &#39;描述&#39;<br>    git log 显示最近到最远的提交日志<br>    回退到某个版本，HEAD表示当前版本，HEAD^表示上一个版本 HEAD~100表示往上数第一百个版本<br>    git reset --hard HEAD^<br>    git reset --hard 190dee23dkd //后面为要回退版本的id,只用写前几位就可以了<br>    如果回退到某个版本，又后悔了想回到之前的版本，这个时候没有id<br>    git reflog //会显示之前每次的命令</p>\n<p>  2.工作区和暂存区以及本地版本库<br>    工作区(Working Directory)<br>    即电脑里能看到的目录，你自己本地编辑的代码文件<br>    工作区里面有个隐藏目录.git，这个不算工作区，而是Git的版本库（repository）<br>    版本库里有个暂存区（stage或者index），还有自动创建的分支master,以及指向分支的指针HEAD<br>    之前把文件往版本库里添加的时候分两步操作<br>    git add 是把文件修改添加到暂存区<br>    git commit 是把暂存区所有内容提交到当前分支<br>    git checkout --readme.txt 丢弃工作区的修改（即回到最近一次git commit或者git add的状态）</p>\n<p>  3.管理修改<br>  删除版本库中的文件<br>  git rm test.txt 并且commit</p>\n\n        <h3 id=\"四.远程仓库\">\n            <a href='#四.远程仓库' class='header-anchor'>#</a>\n            <span>四.远程仓库</span>\n        </h3>\n    <p>  1.添加远程库并推送本地仓库到远程仓库<br>    linux设置ssh秘钥<br>    ssh-keygen -t rsa -C &#39;wangyangruoshi@163.com&#39;<br>    将公钥添加到github，github中新建仓库(new repository)<br>    在本地关联远程仓库<br>    git remote add origin <a href=\"mailto:git@github.com\">git@github.com</a>:irlen/learngit.git<br>    将本地仓库的内容推送到远程仓库<br>    git push -u origin master  (第一次推送加上-u，不仅推送还会关联，之后推送拉取都可以简化命令)<br>  2.从远程库克隆<br>    git clone <a href=\"mailto:git@github.com\">git@github.com</a>:irlen/gitskills.git</p>\n\n        <h3 id=\"五.分支管理\">\n            <a href='#五.分支管理' class='header-anchor'>#</a>\n            <span>五.分支管理</span>\n        </h3>\n    <p>  1.创建与合并分支<br>    创建dev分支，并切换到dev分支<br>    git checkout -b dev (-b参数表示创建并切换,相当于git branch dev 和 git checkout dev两个命令)<br>    git branch 查看当前分支<br>    将dev分支合并到master分支<br>    git checkout master<br>    git merge dev<br>    删除dev分支<br>    git branch -d dev<br>  2.解决冲突<br>    两个分支改了同一个地方合并的时候发生冲突<br>    git status 可查看冲突的是哪个文件<br>    git会用《《《《《 ==========》》》》》》表示出不同，改统一后再git add 和 git commit<br>    git log --graph 可以看到分支合并图<br>  3.分支管理策略<br>    合并分支时，git会用Fast forward模式，这种模式删除分支后会丢掉分支信息。<br>    禁用Fast forward模式，从分支历史就可以看出分支信息<br>    git merge --no-ff -m &#39;merge with no-off&#39; dev<br>    实际开发中，master分支应该是相当稳定，只用来发布新版本，平时不能在上面干活，干活都在dev分支上，每个人都有自己的dev分支，时不时的往dev分支上合并<br>  4.暂存和删除未合并分支<br>    当你在dev分支上开发到一半，突然要在maser上新建一个bug分支来改bug,这个时候dev分支因为不能提交，需要暂存起来<br>    git stash 暂存现有分支为提交的内容<br>    git stash list 列出暂存的工作现场<br>    git stash pop 恢复工作现场并删除暂存 (相当于git stash apply 和 git stash drop 两个命令的结果)<br>    当你开发一个新功能分支，然后上面告诉你这个并能不要了，那你需要将这个功能分支删除(要用大写-D 参数)<br>    git branch -D branchName<br>  5.多人协作<br>    git remote -v 显示远程仓库的详细细信息<br>    推送分支,要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上<br>    git push origin master<br>    并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？<br>      master分支是主分支，因此要时刻与远程同步；<br>      dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；<br>      bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；<br>      feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。<br>    抓取分支<br>      当从远程库克隆时，默认只能看到本地的master分支，但是需要在dev分支上开发，这时候需要做以下操作<br>      创建远程origin的dev分支到本地<br>      git checkout -b dev origin/dev<br>      假如git add 和git commit之后，git push origin dev 将dev分支推送到远程，此段时间别人也在将本地dev推送到远程，<br>      此时有可能发生冲突，发生冲突如何解决：<br>      git pull 将最新的提交从远程当前分支抓下来合并再提交<br>      这是git pull也失败了，怎么办：<br>      原因是没有指定本地dev分支和远程orgin/dev分支的链接，需要设置：<br>      git branch --set-upstream-to=origin/dev dev<br>      然后再git pull,会自动合并，若合并有冲突，可以修改冲突再提交git commit ,git push</p>\n\n        <h3 id=\"六.标签管理\">\n            <a href='#六.标签管理' class='header-anchor'>#</a>\n            <span>六.标签管理</span>\n        </h3>\n    <p>  1.创建标签<br>  tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起<br>  切换到要打标签的分支，比如dev分支<br>  git checkout dev<br>  给该分支打一个标签<br>  git tag v1.0 （git tag -a tagname -m &#39;描述文字&#39;）<br>  git tag 查看你打的历史标签<br>  删除标签<br>  git tag -d v1.0<br>  2.操作标签<br>  创建的标签都只存储在本地，不会自动推送到远程,可以这样将标签推送到远程<br>  git push origin v1.0<br>  也可以一次性将所有本地标签推送到远程<br>  git push origin --tags<br>  删除远程标签有点麻烦，需要先删除本地，再推送<br>  git tag -d -v1.0<br>  git push origin :refs/tags/v1.0</p>\n\n        <h3 id=\"七.忽略某些文件的上传\">\n            <a href='#七.忽略某些文件的上传' class='header-anchor'>#</a>\n            <span>七.忽略某些文件的上传</span>\n        </h3>\n    <p>建一个.gitignore文件，将需要忽略的文件或者文件夹名字写进去，然后将.gitignore提交到Git</p>\n\n        <h3 id=\"八.搭建私有git服务器\">\n            <a href='#八.搭建私有git服务器' class='header-anchor'>#</a>\n            <span>八.搭建私有git服务器</span>\n        </h3>\n    <p>1.安装git服务的环境<br>  yum -y install curl curl-devel zlib-devel openssl-devel perl cpio expat-devel gettext-devel gcc cc<br>2.下载 git-2.5.0.tar.gz</p>\n<pre class=\"prettyprint\"><code>  解压\n  tar -xvzf git-2.5.0.tar.gz\n\n  cd git-2.5.0\n  autoconf\n  ./configure\n  make\n  make install</code></pre><p>3.添加用户<br>adduser -r -c &#39;git version control&#39; -d /home/irlen -m irlen<br>此命令执行后会创建/home/irlen目录作为irlen用户的主目录，用户名是irlen<br>4.设置密码为irlen<br>passwd irlen<br>这时候可以在主目录中建文件夹，使用git init --bare初始化目录</p>\n\n        <h3 id=\"在IDEA中使用git\">\n            <a href='#在IDEA中使用git' class='header-anchor'>#</a>\n            <span>在IDEA中使用git</span>\n        </h3>\n    <p>配置git<br>settings-&gt;Version Control-&gt;Git<br>工程加入到本地仓库<br>VCS-&gt;Import into Version Control-&gt;Create Git repository</p>\n"},{"context":[{"title":"运维","link":"javascript:void(0)"},{"title":"docker","link":"/ops/docker.html"}],"content":"\n        <h3 id=\"Doker\">\n            <a href='#Doker' class='header-anchor'>#</a>\n            <span>Doker</span>\n        </h3>\n    <p>仓库<br>镜像<br>容器</p>\n<p>下载地址：<br>    win10之外：<br>        <a href=\"https://www.docker.com/products/docker-toolbox\">https://www.docker.com/products/docker-toolbox</a><br>    win10:<br>        <a href=\"https://www.docker.com/products/docker#/windows\">https://www.docker.com/products/docker#/windows</a></p>\n<p>拉取镜像：<br>    docker pull  [options] name [:TAG]<br>查看已拉取的镜像：<br>    docker images [OPTIONS] REPROSITORY [:TAG]<br>运行一个镜像<br>    docker run [OPTIONS] IMAGE [:TAG] [COMMAND] [ARG...]</p>\n<pre class=\"prettyprint\"><code>-d参数表示在后台运行，并会打印出镜像ID</code></pre><p>查看正在机器上运行的容器<br>    docker ps<br>在容器中运行一个命令<br>    docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</p>\n\n        <h3 id=\"安装docker\">\n            <a href='#安装docker' class='header-anchor'>#</a>\n            <span>安装docker</span>\n        </h3>\n    <p>配置各种源的地址<br><a href=\"https://developer.aliyun.com/mirror/\">https://developer.aliyun.com/mirror/</a><br>安装前对centos的操作<br>1.yum包更新到最新<br>sudo yum update</p>\n<p>2.安装需要的包，yum-util提供yum-config-manager功能，另外两个是devicemapper驱动依赖。<br>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</p>\n<p>3.设置yum源为阿里云<br>sudo yum-config-manager --add-repo <a href=\"http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p>\n<p>4.安装docker<br>sudo yum install docker-ce -y</p>\n<p>5.设置ustc镜像（可以提升docker拉取镜像的速度）</p>\n<pre class=\"prettyprint\"><code>//创建文件\nsudo mkdir -p /etc/docker\nvim /etc/docker/daemon.json\n在文件中输入如下内容:\n{\n  &quot;registry-mirrors&quot;:[&quot;https://docker.mirrors.ustc.edu.cn&quot;]\n}</code></pre>\n        <h3 id=\"docker的启动和停止\">\n            <a href='#docker的启动和停止' class='header-anchor'>#</a>\n            <span>docker的启动和停止</span>\n        </h3>\n    <pre class=\"prettyprint\"><code>//启动\nsystemctl start docker\n//查看状态\nsystemctl status docker\n//开机自动启动\nsystemctl enable docker\n//关闭docker\nsystemctl stop docker</code></pre>\n        <h3 id=\"docker常用命令\">\n            <a href='#docker常用命令' class='header-anchor'>#</a>\n            <span>docker常用命令</span>\n        </h3>\n    <p>1.镜像相关操作命令</p>\n<pre class=\"prettyprint\"><code>  //查看docker中有哪些镜像\n    docker images\n\n  //搜索某个镜像\n    docker search centos  \n\n  //拉取镜像\n    docker pull tutum/centos\n\n  //删除镜像（按照ID或者名称都可以，如果镜像有相应容器运行，则该镜像无法删除）\n    docker rmi 镜像ID或者名称\n\n  //删除所有镜像\n    docker rmi `docker images -q`</code></pre><p>2.容器相关操作命令</p>\n<pre class=\"prettyprint\"><code>  //查看容器(正在运行的)\n    docker ps\n\n  //查看所有容器\n    docker ps -a\n\n  //创建与启动容器\n    docker run\n    参数 -i: 表示运行容器；\n\n         -t: (terminal 终端) 表示容器启动后进入命令行。加入这两个命令容器创建就可以进入，即分配一个伪终端；\n\n         --name: 为创建的容器命名；\n\n         -v: 表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个-v做多个目录和文件的映射。\n         注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。\n\n         -d: (daemons 守护进程) 在run后面加上-d参数，则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。\n\n         -p: (port) 表示端口映射，前者宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射；\n         (1)交互式运行一个容器\n         docker run -it --name=centos 镜像名:镜像标签  /bin/bash(表示使用bash脚本命令进行交互)\n         此时，容器运行，光标所在环境为容器环境。\n         退出容器环境\n         exit  (此时容器停止运行)\n\n         (2)守护式方式运行容器\n         docker run -id --name=mycentos2 镜像名:镜像标签\n         此时，容器运行中，光标在宿主机环境\n         进入容器环境\n         docker exec -it mycentos2 /bin/bash\n         然后 exit退出容器环境，此时容器仍然在运行（和交互式创建的容器不同）</code></pre><p>停止容器</p>\n<pre class=\"prettyprint\"><code>  docker stop mycentos2</code></pre><p>启动容器</p>\n<pre class=\"prettyprint\"><code>docker start mycentos2</code></pre><p>查看容器信息</p>\n<pre class=\"prettyprint\"><code>docker inspect 容器名称（或ID）\n//可查看指定参数 ，例如ip\ndocker inspect --format=&#039;{{.NetworkSettings.IPAddress}}&#039; 容器名称(或ID)</code></pre><p>删除容器（要先停止容器运行）<br>docker rm 容器名称（或ID）</p>\n\n        <h3 id=\"文件操作\">\n            <a href='#文件操作' class='header-anchor'>#</a>\n            <span>文件操作</span>\n        </h3>\n    <p>宿主环境下将文件拷入容器中</p>\n<pre class=\"prettyprint\"><code>docker cp haha.json mycentos2:/usr/local</code></pre><p>目录挂载<br>通过-v 参数在创建容器时，将宿主机和容器目录进行映射，之后通过修改宿主机某个文件去影响容器。<br>docker run -id -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos2 centos:7<br>多级目录可能无权限,可添加 --privileged=true 来解决。（privileged 有特权的）</p>\n\n        <h3 id=\"mysql部署\">\n            <a href='#mysql部署' class='header-anchor'>#</a>\n            <span>mysql部署</span>\n        </h3>\n    <p>1.拉取mysql镜像<br>docker pull centos/mysql-57-centos7   //拉取mysql5版本镜像</p>\n<p>2.创建容器<br>docker run -id --name=mymysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=irlen 镜像名称<br>此时可用宿主机的ip和映射端口去连容器内mysql</p>\n\n        <h3 id=\"tomcat部署\">\n            <a href='#tomcat部署' class='header-anchor'>#</a>\n            <span>tomcat部署</span>\n        </h3>\n    <p>1.拉取tomcat镜像<br>docker pull tomcat:7-jre7</p>\n<p>2.创建容器(-p：端口映射，-v:目录映射)<br>docker -id --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/user/local/tomcat/webapps  tomcat:7-jre7</p>\n\n        <h3 id=\"Nginx部署\">\n            <a href='#Nginx部署' class='header-anchor'>#</a>\n            <span>Nginx部署</span>\n        </h3>\n    <p>1.拉取Nginx镜像<br>  docker pull nginx<br>2.创建nginx容器<br>  docker run -id --name=mynginx -p 80:80 nignx</p>\n\n        <h3 id=\"Redis部署\">\n            <a href='#Redis部署' class='header-anchor'>#</a>\n            <span>Redis部署</span>\n        </h3>\n    <p>1.拉取Redis镜像<br>docker pull redis<br>2.创建容器<br>docker run -id --name=myredis -p 6379:6379 redis</p>\n\n        <h3 id=\"迁移与备份\">\n            <a href='#迁移与备份' class='header-anchor'>#</a>\n            <span>迁移与备份</span>\n        </h3>\n    <p>1.容器保存为镜像<br>  docker commit mynginx mynginx_i<br>2.镜像备份<br>  docker save -o mynginx.tar mynginx_i  //-o  output意思<br>3.镜像恢复与迁移<br>  docker load -i mynginx.tar  //-i input的意思</p>\n\n        <h3 id=\"Dockerfile常用命令\">\n            <a href='#Dockerfile常用命令' class='header-anchor'>#</a>\n            <span>Dockerfile常用命令</span>\n        </h3>\n    <p>Dockerfile是由一系列命令和参数构成的脚本，用于基础镜像并最终创建一个新的镜像。<br>常用命令</p>\n<pre class=\"prettyprint\"><code>FROM  镜像名   //从哪个基础镜像启动构建流程\nMANITAINER irlen //创建进行的作者\nENV  key:value  //设置环境变量（可写多条）\nRUN  命令  //dockerfile核心部分（可写多条）\nADD  宿主文件 容器文件  //将宿主文件复制到容器内，如果是压缩文件会自动解压\nCOPY 宿主文件 容器文件  //同上，但是压缩文件不会自己解压\nWORKDIR 文件夹  //设置工作目录</code></pre>\n        <h3 id=\"使用Dockerfile创建镜像（脚本文件名称必须叫Dockerfile）\">\n            <a href='#使用Dockerfile创建镜像（脚本文件名称必须叫Dockerfile）' class='header-anchor'>#</a>\n            <span>使用Dockerfile创建镜像（脚本文件名称必须叫Dockerfile）</span>\n        </h3>\n    <pre class=\"prettyprint\"><code>example: 用Dockerfile创建一个jdk1.8的镜像\n文件名称 Dockerfile\n文件内容\n  FROM centos:7\n  MANITAINER irlen\n  WORKDIR /usr\n  RUN mkdir /usr/local/java\n  ADD jdk-yu171-linux-x64.tar.gz /usr/local/java/\n\n  ENV JAVA_HOME /usr/local/java/jdk1.8.0_171\n  ENV JRE_HOME $JAVA_HOME/jre\n  ENV CLASSPATH $JAVA_HOME/bin/dt.jar:$JAVA_HJOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH   //linux用冒号代表分号\n  ENV PATH $JAVA_HOME/bin:$PATH\n\n  //执行Dockerfile创建镜像\n  docker build -t=&quot;镜像名称&quot; .   //.表示在当前文件中寻找Dockerfile文件\n</code></pre>\n        <h3 id=\"Docker私有仓库\">\n            <a href='#Docker私有仓库' class='header-anchor'>#</a>\n            <span>Docker私有仓库</span>\n        </h3>\n    <p>私有仓库搭建与配置<br>1.拉取私有仓库镜像（私有仓库本身也是一个镜像）<br>  docker pull registry<br>2.启动私有仓库容器<br>  docker run -id --name=registry -p 5000:5000 registry<br>3.打开浏览器查看host:5000/v2/_catalog看到{&quot;repositories&quot;:[]} 表示私有仓库搭建成功并且内容为空。</p>\n<p>4.修改daemon.json  让docker信任私有仓库地址。</p>\n<pre class=\"prettyprint\"><code>vim /etc/docker/daemon.json\n添加(host为宿主机ip)\n{\n  “insecure-registries”:[host地址:5000]\n}\n重启docker服务\nsystemctl restart docker</code></pre><p>将镜像上传到私有仓库（私有仓库容器需要启动）<br>docker tag 镜像名 私服地址:端口/镜像名<br>docker push 私服地址:端口/镜像名</p>\n<p>从私有仓库下载镜像</p>\n"},{"context":[{"title":"正则","link":"javascript:void(0)"},{"title":"正则","link":"/regexp/regexp.html"}],"content":"\n        <h3 id=\"1.简介\">\n            <a href='#1.简介' class='header-anchor'>#</a>\n            <span>1.简介</span>\n        </h3>\n    <p>普通字符： 包括没有显式指定为元字符的所有可打印和不可打印字符，包括大小写字母，所有数字，所有标点符号和一些其他字符。<br>非打印字符： \\f     匹配一个换页符，<br>                     \\n    匹配一个换行符，<br>                     \\r     匹配一个回车符，<br>                     \\s     匹配任何空格字符，包括空格制表符，换页符等（Unicode正则表达式会匹配全角空格符）,<br>                     \\S    匹配任何非空白字符，<br>                     \\t     匹配一个制表符，<br>                     \\v    匹配一个垂直制表符</p>\n<p>特殊字符：就是有特殊含义的字符，如果查找其本身，需要用\\进行转义<br>$    匹配字符串的结尾位置（如果设置了RegExp对象的Multiline属性，则$也匹配\\n或者\\r），<br>^    匹配夫字符串的开始位置，若在方括号表达式中使用，此时它表示不接受该字符结合</p>\n<ul>\n<li>匹配前面的子表达式0次或多次，</li>\n</ul>\n<ul>\n<li>匹配前面子表达式一次或者多次<br>?     匹配前面子表达式零次或一次，或者指定一个非贪婪限定符。</li>\n</ul>\n<p>.    匹配除换行符\\n之外的任意单字符</p>\n<p>()    标记一个子表达式的开始和结束位置，子表达式可以获取供以后使用，<br>[]    匹配一个中括号表达式的开始和结束，一般指一系列字符集合<br>{}    限定表达式的开始和结束符号，一般内表达式限定字符的长度或者范围</p>\n<p>\\     将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符<br>|    指明两项中间选择其一</p>\n<p>限定符：限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。</p>\n<ul>\n<li>匹配前面子表达式零次或多次，</li>\n</ul>\n<ul>\n<li>匹配前面子表达式一次或多次，<br>?    匹配面前子表达式零次或一次，<br>{n}    n是一个非负整数，匹配确定的n次,<br>{n,}    n是一个非负整数，至少匹配n次，<br>{n,m}    m和n均为非负整数，其中n&lt;=m,表示最少匹配n次，最多匹配m次（在逗号和两个数之间不能有空格），</li>\n</ul>\n<p>定位符：定位符用来描述字符串或单词的边界，<br>^    匹配输入字符串开始的位置（如果设置了RegExp对象的Multiline属性，^还会与\\n或者\\r之后的位置匹配）<br>$    匹配输入字符串结尾的位置（如果设置了RegExp对象的Multiline属性，^还会与\\n或者\\r之前的位置匹配）<br>\\b    匹配一个单词边界，即字与空格之间的位置<br>\\B    非单词边界匹配<br>注意： 不能将定位符和限定符一起使用，由于在紧靠换行或者单词边界的前面或者后面不能有一个以上的位置，因此不允许诸如^*之类的表达式。</p>\n<p>选择：用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。<br>其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。<br>反向引用：对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。<br>可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。<br>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。<br>i表示不区分大小写，g表示全局匹配</p>\n\n        <h3 id=\"2.元字符\">\n            <a href='#2.元字符' class='header-anchor'>#</a>\n            <span>2.元字符</span>\n        </h3>\n    <p>\\    将下一个字符标记为一个特殊字符，或一个原意字符，或一个向后引用，或一个八进制转义符。<br>^      匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 &#39;\\n&#39; 或 &#39;\\r&#39; 之后的位置。<br>$     匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 &#39;\\n&#39; 或 &#39;\\r&#39; 之前的位置。</p>\n<ul>\n<li>匹配前面的子表达式零次或多次</li>\n</ul>\n<ul>\n<li>匹配前面子表达式一次或多次<br>？    匹配前面子表达式零次或一次， 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例            如，对于字符串 &quot;oooo&quot;，&#39;o+?&#39; 将匹配单个 &quot;o&quot;，而 &#39;o+&#39; 将匹配所有 &#39;o&#39;。<br>{n}    n是一个非负整数，匹配确定的n次<br>{n,}    n是一个非负整数，至少匹配n次<br>{n,m}    n和m皆为非负整数，n&lt;=m，至少匹配n次，至多匹配m次<br>(pattern)    匹配括号中pattern，并获取这一匹配，所获取的匹配可以从产生的matches集合中得到，在js中则使用$0...$9属性。<br>(?:pattern)    匹配pattern ，但不获取匹配结果，  &#39;industr(?:y|ies) 就是一个比 &#39;industry|industries&#39; 更简略的表达式<br>(?=pattern)    正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，这是一个非获取匹配， 例如，&quot;Windows(?=95|98|NT|2000)&quot;能匹配&quot;Windows2000&quot;中的&quot;Windows&quot;，但不能匹配&quot;Windows3.1&quot;中的&quot;Windows&quot;<br>(?!pattern)     正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，这是一个非获取匹配， 例如&quot;Windows(?!95|98|NT|2000)&quot;能匹配&quot;Windows3.1&quot;中的&quot;Windows&quot;，但不能匹配&quot;Windows2000&quot;中的&quot;Windows&quot;<br>(?&lt;=pattern) 反向肯定预查，与正向肯定预查类似，只是方向相反， 例如，&quot;(?&lt;=95|98|NT|2000)Windows&quot;能匹配&quot;2000Windows&quot;中的&quot;Windows&quot;，但不能匹配&quot;3.1Windows&quot;中的&quot;Windows&quot;<br>(?&lt;!pattern)  反向否定预查，与正向否定预查类似，只是方向相反，例如，&quot;(?&lt;!95|98|NT|2000)Windows&quot;能匹配&quot;3.1Windows&quot;中的&quot;Windows&quot;,但不能匹配&quot;2000Windows&quot;中的&quot;Windows&quot;<br>x|y    匹配x或者y<br>[xyz]    字符集合，匹配包含的任意一个字符， 例如， &#39;[abc]&#39; 可以匹配 &quot;plain&quot; 中的 &#39;a&#39;<br>[^xyz] 匹配未包含的任意字符， 例如， &#39;[^abc]&#39; 可以匹配 &quot;plain&quot; 中的&#39;p&#39;、&#39;l&#39;、&#39;i&#39;、&#39;n&#39;<br>[a-z]     匹配a-z范围内的所有字符<br>[^a-z]    匹配a-z范围以外的所有字符<br>\\b    匹配一个单词边界，也就是单词和空格之间的位置， 例如， &#39;er\\b&#39; 可以匹配&quot;never&quot; 中的 &#39;er&#39;，但不能匹配 &quot;verb&quot; 中的 &#39;er&#39;。<br>\\B    匹配非单词边界，例如， &#39;er\\B&#39; 能匹配 &quot;verb&quot; 中的 &#39;er&#39;，但不能匹配 &quot;never&quot; 中的 &#39;er&#39;。<br>\\cx  匹配由x指明的控制符，c相当于control,例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 &#39;c&#39; 字符。<br>\\d    匹配一个数字字符，等价于[0-9].<br>\\D    匹配一个非数字字符，等价于[^0-9]<br>\\w    匹配字母，数字，下划线。等价于[A-Za-z0-9_]<br>\\W    匹配非字符数字下划线。等价于[^A-Za-z0-9_]<br>\\f    匹配一个换页符， 等价于 \\x0c 和 \\cL。<br>\\n    匹配一个换行符，等价于 \\x0a 和 \\cJ<br>\\r    匹配一个回车符，等价于\\x0d和\\cM<br>\\t    匹配一个指标符，等价于\\x09和\\cl<br>\\v    匹配一个垂直制表符，等价于\\x0b和\\cK<br>\\s    匹配任何空白字符，包括空格，制表符，换页等等，等价于[\\f\\n\\r\\t\\v]<br>\\S    匹配任何非空白字符，等价于[^\\f\\n\\r\\t\\v]</li>\n</ul>\n<p>\\xn    匹配n,其中n为一个十六进制转意值。十六进制转移值必须为确定的两个数字长。例如： &quot;\\x41&quot;匹配“A”，&quot;\\x041&quot;则等价于&quot;\\x04&quot;&amp;&quot;1&quot;。正则表达式可以使用ASII编码。<br>\\num    匹配num，其中num是一个正整数。对所获取的匹配的应用。例如，&#39;(.)\\1&#39;匹配两个连续的相同字符。<br>\\n     标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。<br>\\nm     标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。<br>\\nml     如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。<br>\\un         匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。</p>\n<p>i：ignorCase忽略大小写<br>m：mutiple允许多行匹配<br>g：globle进行全局匹配，指匹配到目标串的结尾</p>\n<p>3.运算优先级<br>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。<br>相同优先级的从左到右进行运算，不同优先级的运算先高后低。<br>下面表格优先级从高到低排列<br><img src=\"../docs/regexp/youxianji.png\" alt=\"优先级\"></p>\n"}];

  var escapeHtml = function (html) {
    let str = html;
    str = str.replace(/&/g, '&amp;');
    str = str.replace(/</g, '&lt;');
    str = str.replace(/>/g, '&gt;');
    str = str.replace(/"/g, '&quot;');
    str = str.replace(/'/g, '&#039;');
    return str;
  }

  var clearHtml = function (html) {
    let str = html;
    str = str.replace(/&amp;/g, '');
    str = str.replace(/&lt;/g, '');
    str = str.replace(/&gt;/g, '');
    str = str.replace(/&quot;/g, '');
    str = str.replace(/&#039;/g, '');
    return str;
  }

  var randStr = function () {
    return Math.random().toString(36).substr(2);
  };

  var findTitle = function (ele) {
    var findPrevs = function (ele) {
      var children = $(ele).parent().children();
      var prevs = [];
      var findIt = false;
      children = Array.prototype.slice.call(children);
      children.forEach(function (subEle) {
        if ($(subEle).is($(ele))) {
          findIt = true;
        }
        if (findIt === false && $(subEle).text() != "") {
          prevs.push(subEle);
        }
      });
      return prevs;
    };

    var findH = function (eles) {
      var _eles = Array.prototype.slice.call(eles);
      _eles.reverse();
      var title = "";
      var id = "";
      _eles.forEach(function (item) {
        if (!title) {
          if (item.nodeName[0] === "H") {
            title = $(item).text();
            id = $(item).attr("id");
          }
        }
      });
      return {
        text: title,
        id: id
      };
    };
    var prevs = findPrevs(ele);
    if (prevs.length) {
      return findH(prevs);
    }
  };

  window.searchData = function (keyword) {
    var searchResult = [];
    content.forEach(function (item, index) {
      var tempHtml = "<div id='" + randStr() + "'></div>";
      var tempEle = $(tempHtml);
      var findArray = [];
      tempEle.html(clearHtml(item.content));
      findArray = tempEle.find(":contains('" + keyword + "')");
      findArray = Array.prototype.slice.call(findArray);
      if (findArray.length) {
        findArray.forEach(function (ele) {
          var findContent = $(ele).text();
          findContent = findContent[0] === "<" ? $(findContent).text() : findContent;
          findContent = escapeHtml(findContent);
          findContent = findContent.replace(new RegExp(keyword, 'g'), "<b>" + keyword + "</b>");
          var hObj = findTitle(ele);
          if (hObj) {
            searchResult.push({
              context: item.context,
              title: hObj.text,
              hid: hObj.id,
              findContent: findContent
            });
          }
        });
      }
    });
    return searchResult;
  };
})();
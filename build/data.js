(function () {
  var content = [{"context":[{"title":"介绍","link":"/index.html"}],"content":"\n        <h3 id=\"此文档主要用于学习记录\">\n            <a href='#此文档主要用于学习记录' class='header-anchor'>#</a>\n            <span>此文档主要用于学习记录</span>\n        </h3>\n    <p>最近修改于2020年03月23日<br>github地址：<a href=\"https://github.com/irlen/note\">https://github.com/irlen/note</a></p>\n"},{"context":[{"title":"大前端","link":"javascript:void(0)"},{"title":"react","link":"javascript:void(0)"},{"title":"react-hooks","link":"/front/react/react-hooks.html"}],"content":"\n        <h3 id=\"react-hooks\">\n            <a href='#react-hooks' class='header-anchor'>#</a>\n            <span>react-hooks</span>\n        </h3>\n    <p>为什么只能在函数最外层调用 Hook，不要在循环、条件判断或者子函数中调用？<br>为什么 useEffect 第二个参数是空数组，就相当于 ComponentDidMount ，只会执行一次？<br>React Hooks 分为内置的和自定义的两种类型，内置的 hooks 有以下几个：</p>\n\n        <h3 id=\"Basic-Hooks\">\n            <a href='#Basic-Hooks' class='header-anchor'>#</a>\n            <span>Basic Hooks</span>\n        </h3>\n    <p>useState<br>useEffect<br>useContext</p>\n\n        <h3 id=\"Additional-HooksuseReducer\">\n            <a href='#Additional-HooksuseReducer' class='header-anchor'>#</a>\n            <span>Additional HooksuseReducer</span>\n        </h3>\n    <p>useCallback<br>useMemo<br>useRef<br>useImperativeHandle<br>useLayoutEffect<br>useDebugValue</p>\n\n        <h3 id=\"1.useState\">\n            <a href='#1.useState' class='header-anchor'>#</a>\n            <span>1.useState</span>\n        </h3>\n    <p>const [count,setCount] = useState(0);<br>setCount(),可直接输入要设置的值，也可以传入带参数函数，参数为上一次count值，经过计算处理返回。</p>\n<pre class=\"prettyprint\"><code>  setCount(previous=&amp;gt;{\n    return revious+10\n  })</code></pre><p>注意： useState 的参数可以是基本类型，也可以是对象类型，在更新对象类型时，切记要合并旧的状态，否则旧的状态会丢失</p>\n<pre class=\"prettyprint\"><code>setCount({\n  ...params,\n  countone: 200\n})</code></pre>\n        <h3 id=\"2.useEffect/useLayoutEffect\">\n            <a href='#2.useEffect/useLayoutEffect' class='header-anchor'>#</a>\n            <span>2.useEffect/useLayoutEffect</span>\n        </h3>\n    <p>useEffect是ReactHooks的核心,可取代componentDidMount、componentDidUpdate、componentWillUnmount三个周期。<br>useEffect接受两个参数，其中第二个参数是可选的，不过一般情况下都需要传入第二个参数。</p>\n<pre class=\"prettyprint\"><code>useEffect(()=&amp;gt;{\n\n    return ()=&amp;gt;{}\n},[])</code></pre><p>第一个参数为一个函数，为必传参数，当组件数次渲染或者其依赖的状态改变时会执行，该函数的返回值是可选的，可以不写，如果要写的话必须是一个函数，用于清除上一个状态。</p>\n<p>第二个参数为可选参数，是一个数组。数组中可以传入状态值（通过useState产生的值），当状态值改变的时候首先会执行return函数（即第一个参数中函数的返回值函数），用于清理上一个状态，然后useEffect中的函数就会再次执行。</p>\n<p>***如果不传入第二个参数，代表组件中任何状态的改变，effect都会执行一次，这通常不是我们想要的行为。</p>\n<p>***如果第二个参数传递一个空数组，代表efffect只会执行一次，相当于componentDidmount,return函数也只会在组件卸载的时候执行一次，相当于componentWillUnmount。</p>\n<p>***如果第二个参数数组中有一个或者多个状态值，那么只要有任意一个状态值发生变化，该effect都会再次执行。相当于componentDidUpdate。</p>\n<p>***useEffect是在组件状态改变之后，并且在组件layout和paint之后，也就是说组件出现在页面后再进行调用，useLayoutEffect是在组件状态改变后，但是在组件layout和paint之前，也就是在组件出现在页面之前进行调用。</p>\n<p>***useEffect是异步的，useLayoutEffect是同步的。useEffect不会堵塞主线程渲染。</p>\n\n        <h3 id=\"3.useRef\">\n            <a href='#3.useRef' class='header-anchor'>#</a>\n            <span>3.useRef</span>\n        </h3>\n    <pre class=\"prettyprint\"><code>function xxx(){\n  const inputRef = useRef(null);\n  useEffect(()=&amp;gt;{\n      inputRef.current.value = &#039;hello&#039;\n  },[])\n  return (\n      &amp;lt;input type=&quot;text&quot; ref={inputRef} /&amp;gt;\n  )\n}</code></pre><p>useRef 接收一个初始值，返回一个可变的ref对象，ref.current指向初始化的值。它可以指向别的值。<br>由于是函数组件，this不再指向这个组件，所以要达到class组件中实例变量的效果，可以通过useRef来实现。<br>如果你的 effect 返回一个函数，React 将会在执行清除操作时调用它：<br>为什么 effect 的清除阶段在每次重新渲染时都会执行，而不是只在卸载组件的时候执行一次。让我们看一个实际的例子，看看为什么这个设计可以帮助我们创建 bug 更少的组件。</p>\n\n        <h3 id=\"4.useContext\">\n            <a href='#4.useContext' class='header-anchor'>#</a>\n            <span>4.useContext</span>\n        </h3>\n    <p>useContext的参数必须是context本身；<br>设置context , const ThemContext = React.createContext(themes.light);<br>const value = useContext(MyContext);<br>因为没有static的限制，同一个组件中可以使用多个useContext。也就是说，可以使用多个上层组件传递来的数据。</p>\n\n        <h3 id=\"5.useReducer\">\n            <a href='#5.useReducer' class='header-anchor'>#</a>\n            <span>5.useReducer</span>\n        </h3>\n    <p>提到reducer，首先想到的应该是redux中的reducer。useReducer这个hook与redux中的reducer有所相似又有所不同。可以查看demo中的useReducer。<br>const [state, dispatch] = useReducer(reducer,initialState);<br>要预先写好reducer。<br>dipatch({type:&#39;ADD&#39;});<br>与redux中的reducer有所不同的是，useReducer中的reducer是独立的。如果有多个组件使用到了同一个reducer，那么它们之间的状态是独立的。相较于redux的全局共享状态，它还依赖于react-redux提供的Provider组件。<br>所以是不是突然想到了第四点中的Context，它提供了Provider。如果能配合useReducer，就可以实现全局状态共享了？确实如此！</p>\n\n        <h3 id=\"6.useImperativeHandle\">\n            <a href='#6.useImperativeHandle' class='header-anchor'>#</a>\n            <span>6.useImperativeHandle</span>\n        </h3>\n    <p>useImperativeHandle这个hook是ref的另一种写法。现在通过这个hook可以在子组件中暴露一些API供父组件调用。而父组件是不能直接操作子组件的dom元素的。</p>\n\n        <h3 id=\"7.useCallback\">\n            <a href='#7.useCallback' class='header-anchor'>#</a>\n            <span>7.useCallback</span>\n        </h3>\n    <p>父组件通过props传给子组件一个函数，这个函数用到父组件中的state,如果state改变的时候， memo子组件不会检测到属性的变化，useCallback就是为了解决这一问题，它缓存了一个函数，并接受一系列依赖项，返回一个函数，如果依赖项变化，函数变化。</p>\n<pre class=\"prettyprint\"><code>const handleChange =useCallback (()=&amp;gt;{\n        setResult(count + 1);  //count为父组件的一个state\n},[count])\n//子组件\n&amp;lt;Children  onChange={handleChange} /&amp;gt;</code></pre>\n        <h3 id=\"8.useMemo\">\n            <a href='#8.useMemo' class='header-anchor'>#</a>\n            <span>8.useMemo</span>\n        </h3>\n    <p>useMomo用来缓存一个复杂的计算值，useCallback(fn,deps)等价于useMomo(()=&gt;fn,deps)。如果通过一个输入得到一个值需要经过复杂的计算，那么下次同样的输入再进行一遍同样复杂的计算是没有必要的。这就是useMemo的意义。<br>const result = useMemo(()=&gt;computedExpensiveValue(40),[count]);<br>const result = computedExpensiveValue(40);<br>重新计算result的时候，如果count值没变，就直接从缓存里面读取，避免性能消耗。</p>\n<p>9.useDebugValue</p>\n<p>通常来说你不需要它。它只会存在于自定义的hooks中用来标志一个自定义的hooks。当在chrome中打开react扩展时候，如果一个组件使用到了自定义的hooks，并且该hooks使用到了useDebugValue，那么该组件下方会显示useDebugValue传入的参数。</p>\n<pre class=\"prettyprint\"><code>  function useUserInfo() {\n    // ...\n    useDebugValue(&#039;use-user-info&#039;);\n    return userInfo;\n  }\n</code></pre>"},{"context":[{"title":"大前端","link":"javascript:void(0)"},{"title":"vue","link":"javascript:void(0)"},{"title":"vue工程","link":"/front/vue/project.html"}],"content":"\n        <h1 id=\"vue工程\">\n            <a href='#vue工程' class='header-anchor'>#</a>\n            <span>vue工程</span>\n        </h1>\n    "},{"context":[{"title":"大前端","link":"javascript:void(0)"},{"title":"vue","link":"javascript:void(0)"},{"title":"vue基础语法","link":"/front/vue/vuebase.html"}],"content":"\n        <h3 id=\"vue语法\">\n            <a href='#vue语法' class='header-anchor'>#</a>\n            <span>vue语法</span>\n        </h3>\n    <p>#模板中显示数据<br>{{}}，v-text=&quot;&quot;,v-html=&quot;字符串中包含标签将作为html解析&quot;</p>\n<p>#绑定事件<br>v-on:click=&quot;handleClick&quot;  @click=&quot;handleClick&quot;</p>\n<p>#属性绑定<br>v-bind:title=&quot;title&quot;  , :title=&quot;&quot;</p>\n<p>#双向数据绑定<br>v-model=&quot;&quot;</p>\n<p>#vue中的计算属性和侦听器</p>\n<pre class=\"prettyprint\"><code>computed:{\n    fullName: function(){\n        return this.firstName+&#039; &#039;+this.lastName;\n    }\n}\nwatch:{\n    fullName:function(){\n        监听fullName,如果fullName发生变化，就做出相应变化；\n    }\n}</code></pre><p>#vue中条件判断和循环</p>\n<pre class=\"prettyprint\"><code>v-if=&quot;ture&quot; ， v-show=&quot;true&quot;\n&amp;lt;li v-for=&quot;item of list&quot;&amp;gt;{{item}}&amp;lt;/li&amp;gt;</code></pre><p>#vue中样式和class的绑定<br>style=&quot;原生的样式&quot;<br>:style=&quot;{一个样式的对象，数据可以来自vue实例中的成员变量}&quot;<br>:class=&quot;{&#39;active&#39;: true}&quot; 绑定单个class,并判断是否生效<br>:class=&quot;[{&#39;active&#39;: true},{&#39;isShow&#39;:true}]&quot;<br>#vue中数据传递<br>1.父组件向子组件传递数据props</p>\n<p>父组件将值绑定到子组件属相上:data= &quot;data&quot;<br>子组件</p>\n<pre class=\"prettyprint\"><code>export default {\n    props: [&#039;logo&#039;]\n}\n使用的时候，直接{{logo}}\n```\n2.子组件向父组件传值\n```\n//子组件\n&amp;lt;input @change=&quot;setUser&quot; /&amp;gt;\ndata(){\n    return {\n        username:&#039;&#039;\n    }\n},\nmethods:{\n    setUser: function(){\n        this.$emit(&#039;transferUser&#039;,this.username);\n    }\n}\n//父组件\n&amp;lt;子组件 @transferUser=&quot;getUser&quot;&amp;gt;&amp;lt;/子组件&amp;gt;\nmethods:{\n    getUser(username){\n        this.user=username\n    }\n}\n```\n\n\n\n\n### Vue-cli\nvue工程的脚手架工具\n#全局安装vue-cli\nnpm install -g @vue/cli  @vue/cli-service-global\\\n\n#创建基于webpack模板的新项目\nvue create todolist\n\n#到应用目录下启动项目\nnpm run serve\n\n### 集成element-ui组件库\n\n#安装组件库\ncnpm install -S element-ui\n\n#在main.js中引入，全局可用\nimport ElementUI from &#039;element-ui&#039;\nimport  &#039;element-ui/lib/theme-chalk/index.css&#039;\nVue.use(ElementUI);\n\n\n### vue-router\n\nvue官方路由解决方案\n\n#组件标签\n```\n&amp;lt;div&amp;gt;\n    &amp;lt;router-link to=&quot;/foo&quot;&amp;gt;&amp;lt;/router-link&amp;gt;\n    //匹配到的组件将渲染到这里\n    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;\n&amp;lt;/div&amp;gt;\n```\n#定义路由\n```\nconst routes = [\n    {path:&#039;/foo&#039;,component: Foo},\n    {path:&#039;bar&#039;,component: Bar}\n]\n```\n\n#创建router实例\n```\nconst router = new VueRouter({\n    routes\n})\n```\n#创建和挂载根实例\n```\nconst app = new Vue({\n    router\n}).$mount(&quot;#app&quot;);\n```\n#动态路由传参\n```\nroutes: [\n    {path: &#039;/user/:id&#039;,component: User}\n]\n```\n\n#监测路由变化\n```\nwatch: {\n    &#039;$route&#039;(to,from){\n        //对路由变化做出回应\n    }\n}\n\n```\n#使用路由的一些方法\n\n//获取参数\nthis.$route.params.username;\n//后退\nthis.$router.go(-1);\n//跳转到新的路由\nthis.$router.push(&quot;/&quot;);\nthis.$router 和 router 使用起来完全一样。我们使用 this.$router 的原因是我们并不想在每个独立需要封装路由的组件中都导入路由\n\n#2.2中引入了导航守卫beforeRouteUpdate\n```\nconst User = {\n    template: &#039;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&#039;,\n    beforeRouterUpdate(to,from,next){\n        //执行响应操作，不要忘记回调next();\n    }\n}\n```\n#匹配404\n将这个路由匹配放到最后面\n```\n{\n    path: &#039;*&#039;,//会匹配所有路径\n    component: 404\n}\n```\n当使用通配符时，$route.params内会自动添加一个名为 pathMatch 参数，它包含了URL通过通配符匹配到的东西\nthis.$route.params.pathMatch;\n\n#嵌套路由\n```\nconst User = {\n  template: `\n    &amp;lt;div class=&quot;user&quot;&amp;gt;\n    &amp;lt;h2&amp;gt;User {{ $route.params.id }}&amp;lt;/h2&amp;gt;\n    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;\n    &amp;lt;/div&amp;gt;`\n}\nconst router = new VueRouter({\n  routes: [\n    {\n      path: &#039;/user/:id&#039;, component: User,\n      children: [\n        {\n          // 当 /user/:id/profile 匹配成功，\n          // UserProfile 会被渲染在 User 的 &amp;lt;router-view&amp;gt; 中\n          path: &#039;profile&#039;,\n          component: UserProfile\n        },\n        {\n          // 当 /user/:id/posts 匹配成功\n          // UserPosts 会被渲染在 User 的 &amp;lt;router-view&amp;gt; 中\n          path: &#039;posts&#039;,\n          component: UserPosts\n        }\n      ]\n    }\n  ]\n})\n```\n基于上面的配置，当你访问 /user/foo 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由：\n\n```\nconst router = new VueRouter({\n  routes: [\n    {\n      path: &#039;/user/:id&#039;, component: User,\n      children: [\n        // 当 /user/:id 匹配成功，\n        // UserHome 会被渲染在 User 的 &amp;lt;router-view&amp;gt; 中\n        { path: &#039;&#039;, component: UserHome },\n\n        // ...其他子路由\n      ]\n    }\n  ]\n})\n```\n\n#命名路由\n```\nconst router = new VueRouter({\n    routes:[\n        {\n            path:&#039;/user/:userId&#039;,\n            name:&#039;user&#039;,\n            component: User\n         }\n    ]\n})\n```\n使用时\n```\n&amp;lt;router-link to=&quot;{name:&#039;user&#039;,params:{userId:123}}&quot;&amp;gt;user&amp;lt;/router-link&amp;gt;\nrouter.push({name:&#039;user&#039;,params:{userId:123}});\n```\n#命名视图\n同一个url可以在一个页面上显示多个视图，只要对应好视图名字，未命名的视图则是default\n```\n&amp;lt;div&amp;gt;\n    &amp;lt;router-view class=&quot;view one&quot;&amp;gt;&amp;lt;/router-view&amp;gt;\n    &amp;lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&amp;gt;&amp;lt;/router-view&amp;gt;\n    &amp;lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&amp;gt;&amp;lt;/router-view&amp;gt;\n&amp;lt;/div&amp;gt;\nconst router = new VueRouter({\n  routes: [\n    {\n      path: &#039;/&#039;,\n      components: {\n        default: Foo,\n        a: Bar,\n        b: Baz\n      }\n    }\n  ]\n})\n\n```\n#重定向和别名\n```\nconst router = new VueRouter({\n    routes:[\n        {path:&#039;/a&#039;,redirect:&#039;/b&#039;}  \n        或着 {path:&#039;&#039;,redirect:{name:&#039;foo&#039;}}\n        或者 {path:&#039;/a&#039;,redirect: to=&amp;gt;{\n            //方法接收目标路由作为参数\n            //return 重定向字符串路径或者路径对象\n       }}\n    ]\n})\n\n```\n#别名\n给‘/a’匹配别名‘/b’，则访问‘/b’和访问‘/a’是一样的\n```\nconst router = new VueRouter({\n    routes:[\n        {path: &#039;/a&#039;,component: A, alias: &#039;/b&#039;}\n    ]\n})\n//alias 别名\n```\n#路由组件传参\n通过props将组件和路由解耦\n如果 props 被设置为 true，route.params 将会被设置为组件属性\n```\nconst User = {\n  props: [&#039;id&#039;],\n  template: &#039;&amp;lt;div&amp;gt;User {{ id }}&amp;lt;/div&amp;gt;&#039;\n}\nconst router = new VueRouter({\n  routes: [\n    { path: &#039;/user/:id&#039;, component: User, props: true },\n\n    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：\n    {\n      path: &#039;/user/:id&#039;,\n      components: { default: User, sidebar: Sidebar },\n      props: { default: true, sidebar: false }\n    }\n  ]\n})\n```\n基本都是通过props传递\n\nvue-router默认使用hash路由，不需要后端支持，可用浏览器直接打开，\nhistory路由需要后端环境支持\n使用history路由，后端nginx支持\nnginx\n```\nlocation / {\n  try_files $uri $uri/ /index.html;\n}\n```</code></pre>"},{"context":[{"title":"数据库","link":"javascript:void(0)"},{"title":"mysql","link":"/database/mysql.html"}],"content":"\n        <h1 id=\"mysql\">\n            <a href='#mysql' class='header-anchor'>#</a>\n            <span>mysql</span>\n        </h1>\n    "},{"context":[{"title":"java","link":"javascript:void(0)"},{"title":"mybatis","link":"/java/mybatis.html"}],"content":"\n        <h3 id=\"mybatis\">\n            <a href='#mybatis' class='header-anchor'>#</a>\n            <span>mybatis</span>\n        </h3>\n    <p>####</p>\n"},{"context":[{"title":"java","link":"javascript:void(0)"},{"title":"SpringBoot","link":"/java/springboot.html"}],"content":"\n        <h3 id=\"spring优缺点\">\n            <a href='#spring优缺点' class='header-anchor'>#</a>\n            <span>spring优缺点</span>\n        </h3>\n    <p>优点: 轻量化实现EJB。<br>缺点：配置太繁琐<br>SpringBoot简化了繁琐的配置，使开发的精力集中于业务逻辑代码的编写。<br>SpringBoot不是对Spring功能的增强，而是提供了一个快速使用Spring的方式。</p>\n\n        <h3 id=\"SpringBoot环境搭建\">\n            <a href='#SpringBoot环境搭建' class='header-anchor'>#</a>\n            <span>SpringBoot环境搭建</span>\n        </h3>\n    <p>创建一个module类型的maven工程。</p>\n<p>pom.xml中配置<br>SpringBoot要求，项目要继承SpringBoot的起步依赖spring-boot-starter-parent</p>\n<pre class=\"prettyprint\"><code>  &amp;lt;parent&amp;gt;\n    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;\n    &amp;lt;version&amp;gt;2.0.1.RELEASE&amp;lt;/version&amp;gt;\n  &amp;lt;/parent&amp;gt;</code></pre><p>SpringBoot要继承SpringMVC进行Controller的开发，所以项目要导入web的启动依赖：</p>\n<pre class=\"prettyprint\"><code>&amp;lt;dependencies&amp;gt;\n  &amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;\n  &amp;lt;/dependency&amp;gt;\n&amp;lt;/dependencies&amp;gt;\n</code></pre><p>创建引导类<br>在java中建com.scxgo包，新建文件作为入口文件，例如 MySpringBootApplication类</p>\n<pre class=\"prettyprint\"><code>//此注解声明类是一个SpringBoot的引导类\n@SpringBootApplication\npublic class MySpringBootApplication{\n  //程序入口\n\n  public static void main(String[] args){\n    SpringApplication.run(MySpringBootApplication.class);\n  }\n}</code></pre><p>创建controller<br>创建controller包，建类，类上面加注解@Controller,方法上加@RequestMapping(&quot;/&quot;),@ResponseBody<br>tomcat跑在8080端口<br>IDEA可以自动初始化一个springboot工程<br>创建新工程的时候选择Spring Initializr就可以了。</p>\n\n        <h3 id=\"SpringBoot工程热部署\">\n            <a href='#SpringBoot工程热部署' class='header-anchor'>#</a>\n            <span>SpringBoot工程热部署</span>\n        </h3>\n    <p>pom.xml中需添加依赖<br><dependency><br>  <groupId>org.springframework.boot</groupId><br>  <artifactId>spring-boot-devtools</artifactId><br></dependency><br>注意：热部署失败的原因是 IDEA默认情况下不自动编译，需要对IDEA进行自动编译设置<br>file-settings-Compiler-build project automatically</p>\n<p>shift+ctrl+alt+/,选择Registry-compiler.automake.allow.when.app.running 勾选</p>\n\n        <h3 id=\"SpringBoot配置文件\">\n            <a href='#SpringBoot配置文件' class='header-anchor'>#</a>\n            <span>SpringBoot配置文件</span>\n        </h3>\n    <p>SpringBoot是基于约定的，很多配置都有默认值，需要增加或者覆盖原有配置，可以使用<br>resources文件加下application.properties 或者 application.yml(或者application.yaml)进行配置。（命名规则为application<em>.properties或者application</em>.yml）<br>yml格式</p>\n<pre class=\"prettyprint\"><code>//普通数据的配置\nname: zhangsan  //值前面一定要有个空格\n\n//对象的配置\nperson:\n  name: zhangsan //缩进是自由的，但是要保证每层的缩进是一样的\n  age: 18\n  addr: suizhou\n\n//行内对象配置(用的少)\nperson: {name: zhangsan, age: 18, addr: suizhou}\n\n//配置数组、集合\ncity:\n  - beijing\n  - shanghai\n  - suizhou\n  - shenzhen\n\n//行内数组、集合\ncity: [beijing,shanghai,suizhou,shenzhen]\n\n//配置数组、集合（对象数据）\nstudent:\n  - name: tom\n    age: 18\n    addr: beijing\n  - name: lily\n    age: 25\n    addr: suizhou\n//行内\nstudent: [{name: tom,age: 18,addr:beijing},{name:lily,age:25,addr: suizhou}]</code></pre><p>配置文件与配置类的属性映射<br>有两种方式<br>1.@Value 注解可以将配置文件中的值映射到一个Spring管理的Bean字段上。<br>application.yml中</p>\n<pre class=\"prettyprint\"><code>person:\n  name: zhangsan\n  age: 18\n</code></pre><p>Bean代码如下：</p>\n<pre class=\"prettyprint\"><code>  @Controller\n  public class QuicStartController{\n    @Value(&quot;${person.name}&quot;)\n    private String name;\n    @Value(&quot;${person.age}&quot;)\n    private Integer age;\n  }</code></pre><p>2.@ConfigurationProperties(prefix=&quot;配置文件中key的前缀&quot;)，该注解可以将文件中的配置自动与实体进行映射<br>application.yml中</p>\n<pre class=\"prettyprint\"><code>person:\n  name: zhangsan\n  age: 18</code></pre><p>Bean中</p>\n<pre class=\"prettyprint\"><code>@Controller\n@ConfigurationProperties(prefix=&quot;person&quot;)\npulic class QuikStartController{\n  private String name;\n  private String age;\n  @RequestMapping(&quot;/quik&quot;)\n  @ResponseBody\n  public String quik(){\n    return &quot;my name&quot;+&quot; is &quot;+name;\n  }\n}</code></pre>\n        <h3 id=\"SpringBoot集成\">\n            <a href='#SpringBoot集成' class='header-anchor'>#</a>\n            <span>SpringBoot集成</span>\n        </h3>\n    <p>一.整合mybatis<br>添加mybatis起步依赖</p>\n<pre class=\"prettyprint\"><code>  &amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;artifactId&amp;gt;\n    &amp;lt;version&amp;gt;1.1.1&amp;lt;/version&amp;gt;\n  &amp;lt;/dependency&amp;gt;</code></pre><p>导入数据库坐标（mysql连接驱动）</p>\n<pre class=\"prettyprint\"><code>&amp;lt;dependency&amp;gt;\n  &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;\n  &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;\n&amp;lt;/dependency&amp;gt;</code></pre><p>添加数据库连接信息</p>\n<pre class=\"prettyprint\"><code>spring:\n  datasource:\n    driverClassName: com.mysql.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8\n    username: root\n    password: root</code></pre><p>插入数据(建表sql语句)</p>\n<pre class=\"prettyprint\"><code>//建表语句\n  DROP TABLE IF EXISTS `user`;\n  CREATE TABLE `user`(\n      `id` int(11) NOT NULL AUTO_INCREMENT,\n      `username` varchar(50) DEFAULT NULL,\n      `password` varchar(50)  DEFAUL NULL,\n      `name` varchar(50) DEFAULT NULL,\n      PRIVATE KEY (`id`)\n  ) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;\n\n//插入语句\n  INSERT INTO `user` VALUES (&#039;1&#039;,&#039;zhangsan&#039;,&#039;123&#039;,&#039;张三&#039;);\n  INSERT INTO `user` VALUES (&#039;2&#039;,&#039;lisi&#039;,&#039;123&#039;,&#039;李四&#039;);</code></pre><p>创建实体<br>java内包里见domain包，创建文件User.java建实体类</p>\n<pre class=\"prettyprint\"><code>public class User{\n  private Integer id;\n  private String username;\n  private String password;\n  private String name;\n  //后面为getter，setter方法\n}</code></pre><p>resources文件夹下创建mapper包，里面配置UserMapper.xml</p>\n<pre class=\"prettyprint\"><code>&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;\n&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt;\n\n&amp;lt;mapper namespace=&quot;com.scxgo.mapper.UserMapper&quot;&amp;gt;\n  &amp;lt;select id=&quot;queryUserList&quot; resultType=&quot;user&quot;&amp;gt;\n    select * from user\n  &amp;lt;/select&amp;gt;\n&amp;lt;/mapper&amp;gt;</code></pre><p>java内包中建mapper包，建UserMapper.java文件，写接口</p>\n<pre class=\"prettyprint\"><code>  @Mapper\n  public interface UserMapper{\n    public List&amp;lt;User&amp;gt; queryUserList();\n  }</code></pre><p>在application.yml中配置mybatis信息</p>\n<pre class=\"prettyprint\"><code>mybatis:\n  type-aliases-package: com.scxgo.domain  #pojo别名扫描包\n  mapper-locations: classpath:mapper/*Mapper.xml  #加载mybatis映射文件</code></pre><p>写个controller测试下<br>建包controller</p>\n<pre class=\"prettyprint\"><code>  @Controller\n  public class MybatisController{\n    @Autowired\n    private  UserMapper userMapper;\n    @RequestMapping(&quot;/query&quot;)\n    @ResponseBody\n    public List&amp;lt;User&amp;gt; queryUserList(){\n      List&amp;lt;User&amp;gt; users = userMapper.queryUserList();\n      return users;\n    }\n  }</code></pre>\n        <h3 id=\"集成Junit\">\n            <a href='#集成Junit' class='header-anchor'>#</a>\n            <span>集成Junit</span>\n        </h3>\n    <p>添加Junit起步依赖</p>\n<pre class=\"prettyprint\"><code>  &amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;org.springframwork.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;\n    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;\n  &amp;lt;/dependency&amp;gt;</code></pre><p>编写测试类</p>\n<pre class=\"prettyprint\"><code>@RunWith(SpringRunner.class)\n@SpringBootTest(classes=MyApplication.class) //引导类的字节码\npublic class MyTest{\n  @Test\n  public void test(){\n    ...\n  }\n}</code></pre>\n        <h3 id=\"Spring-Data-JPA集成\">\n            <a href='#Spring-Data-JPA集成' class='header-anchor'>#</a>\n            <span>Spring Data JPA集成</span>\n        </h3>\n    <p>添加起步依赖</p>\n<pre class=\"prettyprint\"><code>&amp;lt;dependency&amp;gt;\n  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n  &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;\n&amp;lt;/dependency&amp;gt;</code></pre><p>添加数据库驱动依赖</p>\n<pre class=\"prettyprint\"><code>&amp;lt;dependency&amp;gt;\n  &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;\n  &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;\n&amp;lt;/dependency&amp;gt;</code></pre><p>在application.yml中配置数据库和jpa相关属性</p>\n<pre class=\"prettyprint\"><code>#DB Configuration\nspring:\n  datasource:\n    driverClassName: com.mysql.jdbc.Driver\n    url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8\n    username: root\n    password: root\n#JPA Configuration\n  jpa:\n    datasource: mysql\n    show-sql: true\n    generate-ddl: true\n    hibernate:\n      ddl-auto: update\n      naming_strategy: org.hibernate.cfg.ImprovedNamingStrategy\n</code></pre><p>在domain文件中创建实体类</p>\n<pre class=\"prettyprint\"><code>@Entiry\npublic class User{\n  @Id\n  @GeneratedValue(strategy=GenerationType.IDENTITY)\n  private Long id;\n  private String username;\n  private String password;\n  private name;\n}</code></pre><p>创建repository包，建UserRepository类</p>\n<pre class=\"prettyprint\"><code>//User为实体类名，Long是实体类中id的数据类型\n@Repository\npublic interface UserRepository extends JpaRepository&amp;lt;User,Long&amp;gt;{\n  public List&amp;lt;User&amp;gt; findAll();\n}</code></pre><p>创建实现类UserImpl</p>\n<pre class=\"prettyprint\"><code></code></pre>\n        <h3 id=\"SpringBoot集成Redis\">\n            <a href='#SpringBoot集成Redis' class='header-anchor'>#</a>\n            <span>SpringBoot集成Redis</span>\n        </h3>\n    <p>安装redis服务器并启动<br>添加redis起步依赖</p>\n<pre class=\"prettyprint\"><code>  &amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;\n  &amp;lt;/dependency&amp;gt;</code></pre><p>在application.yml中注入redis连接信息</p>\n<pre class=\"prettyprint\"><code>spring:\n  redis:\n    host: 127.0.0.1\n    port: 6379</code></pre><p>测试redis服务</p>\n<pre class=\"prettyprint\"><code>@RunWith(&quot;SpringRunner&quot;)\n@SpringBootTest(classes=MySpringBootApplication.class)\npublic class RedisTest{\n  @Autowired\n  private RedisTemplate&amp;lt;String,String&amp;gt; redisTemplate;\n  @Autowired\n  private UserRepository userRepository;\n  @Test\n  public void test(){\n    //1.从redis中去获得需要的数据，一般是json字符串格式\n    String userListJson = redisTemplate.boundValueOps(&quot;user.findAll&quot;).get();\n    //2.判断redis中是否存在数据\n    if(null == userListJson){\n      //3.不存在，则从数据库中查询\n      List&amp;lt;User&amp;gt; all = userRepository.findAll();\n      //4.将查出的数据存储到redis缓存中\n      //存之前先要把list转换成string，此时可是有spring自带的jackson来做\n      ObjectMapper objectMapper = new ObjectMapper();\n      userListJson = objectMapper.writeValueAsString(all);\n      redisTemplate.boundValueOps(&quot;user.findAll&quot;).set(userListJson);\n    }\n\n  }\n}\n</code></pre><p><code></code></p>\n"},{"context":[{"title":"java","link":"javascript:void(0)"},{"title":"annotation","link":"/java/annotation.html"}],"content":"\n        <h3 id=\"IOC容器注解\">\n            <a href='#IOC容器注解' class='header-anchor'>#</a>\n            <span>IOC容器注解</span>\n        </h3>\n    <p>@Component<br>  作用<br>    将当前对象放存入Spring容器。<br>  属性<br>    value: 用于指定bean的id,不指定，则默认为当前类名，且首字母小写。<br>  类似@Component注解<br>@Controller<br>@Service<br>@Repository<br>  作用<br>    同Component注解一样，只是对三层代码类的注解</p>\n<p>@Bean<br>  作用<br>    作用在方法上，将方法的返回值作为bean对象放入spring容器。<br>  属性<br>    name: 用于指定bean的id,不写时，默认值为当前方法名称。<br>  细节<br>    当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。查找的方式和Autowired注解的作用是一样的。</p>\n\n        <h3 id=\"配置相关注解\">\n            <a href='#配置相关注解' class='header-anchor'>#</a>\n            <span>配置相关注解</span>\n        </h3>\n    <p>@Configuration<br>  作用<br>    指定当前类是一个配置类</p>\n<p>@Import<br>  作用<br>    将一个类包含到另一个类，通常是配置类（分配置引入到主配置中）<br>  属性<br>    value: 被引入类的字节码<br>@ComponentScan<br>  作用<br>    用于通过注解指定spring在创建容器时要扫描的包。<br>  属性<br>    value: 它和basePackages的作用是一样的，都是用于制动创建容器时要扫描的包。</p>\n<p>@PropertySource(&quot;classpath:config/spring/.jdbcConfig.properties&quot;)<br>  通常配合@Value使用，不指定配置文件的时候，默认是主配置文件（application.properties或者application.yml）<br>  作用<br>    用于指定properties文件的路径。<br>  属性<br>    value: 指定文件的名称和路径<br>    关键字: classpath,表示类路径下</p>\n<p>@ConfigurationProperties(prefix=&quot;spring&quot;)<br>  作用<br>    将application.yml中的字段自动映射到注解类的成员变量<br>  属性<br>    prefix: 配置文件下字段spring对象下的字段作为映射对象</p>\n\n        <h3 id=\"注入数据\">\n            <a href='#注入数据' class='header-anchor'>#</a>\n            <span>注入数据</span>\n        </h3>\n    <p>@Autowired<br>  作用<br>    自动按照类型注入，只要容器中有唯一的一个bean对象类型和注入变量的类型匹配，就可以注入成功。<br>    如果容器没有类型匹配则报错。<br>    如果容器中有多个类型与之匹配，会报错，此时需要用到Qualifier注解。<br>  位置<br>    可以是变量上，也可以是方法上<br>  @Qualifier(value=&quot;bean的id&quot;)  (本意为限定符，修饰词，合格者)<br>  作用<br>    在按照类型注入的基础之上再按照名称注入，它在给类成员注入时不能单独使用（Autowired注解的类型有多个时使用），但是在给方法参数注入时可以单独使用。<br>  属性<br>    value:被注入的bean的id<br>  注：Qualifier在个方法参数注解的时候可以独立使用，value值为bean的id</p>\n<pre class=\"prettyprint\"><code>    public QueryRunner createQueryRunner(@Qualifier(&#039;ds1&#039;) DataSource dataSource){\n      //有两个返回DataSource类型值的方法被@Bean注解了，此时需要通过id来识别到底是用哪个作为参数\n    }\n</code></pre><p>@Resource(name=&quot;bean的id&quot;)<br>  作用<br>    直接按照bean的id注入，可以独立使用（取代Autowired和Qualifier一起使用的情况）。<br>  属性<br>    name: 被注入的bean的id</p>\n<p>  注意：以上三个注入只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现，另外，集合类型的注入只能通过XML来实现。</p>\n<p>@Value<br>  作用<br>    用于注入基本类型和String类型的数据<br>  属性<br>    value: 用于指定数据的值，它可以使用spring的SpEl（el表达式，即${表达式}）</p>\n\n        <h3 id=\"用于改变作用范围的注解\">\n            <a href='#用于改变作用范围的注解' class='header-anchor'>#</a>\n            <span>用于改变作用范围的注解</span>\n        </h3>\n    <p>@Scope<br>  作用<br>    用于指定bean的作用范围。<br>  属性<br>    value: 指定范围的取值，常用值为 singleton prototype,即单例和多例，不写的时候默认为单例。<br>    <code>@Scope(&amp;quot;prototype&amp;quot;)//多实例，IOC容器启动创建的时候，并不会创建对象放在容器在容器当中，当你需要的时候，需要从容器当中取该对象的时候，就会创建。\n    @Scope(&amp;quot;singleton&amp;quot;)//单实例 IOC容器启动的时候就会调用方法创建对象，以后每次获取\n    @Scope(&amp;quot;request&amp;quot;)//同一个请求创建一个实例\n    @Scope(&amp;quot;session&amp;quot;)//同一个session创建一个实例</code></p>\n\n        <h3 id=\"生命周期相关注解\">\n            <a href='#生命周期相关注解' class='header-anchor'>#</a>\n            <span>生命周期相关注解</span>\n        </h3>\n    <p>@PreDestroy<br>  作用<br>    用在方法上，用于指定该方法为销毁方法。<br>@PostConstruct<br>  作用<br>    用在方法上，用于指定该方法为初始化方法。<br>注：多例对象的销毁spring不负责，所以单例对象销毁之前会调用销毁方法</p>\n\n        <h3 id=\"请求类中的注解\">\n            <a href='#请求类中的注解' class='header-anchor'>#</a>\n            <span>请求类中的注解</span>\n        </h3>\n    <p>请求类一般用@Controller或者@RestController注解<br>类中的方法上的注解<br>@RequestMapping(&quot;/quik&quot;)<br>@ResponseBody</p>\n\n        <h3 id=\"测试类中的注解\">\n            <a href='#测试类中的注解' class='header-anchor'>#</a>\n            <span>测试类中的注解</span>\n        </h3>\n    <p>测试类上的注解<br>@RunWith(SpringRunner.class)<br>@SpringBootTest(classes = MySpringBootApplication.class) //引导类的字节码<br>方法上的注解<br>@Test</p>\n"},{"context":[{"title":"Bash脚本","link":"javascript:void(0)"},{"title":"简介","link":"/bash/introduce.html"}],"content":"\n        <h3 id=\"Bush简介\">\n            <a href='#Bush简介' class='header-anchor'>#</a>\n            <span>Bush简介</span>\n        </h3>\n    <p>Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应<br>Bash 是目前最常用的 Shell</p>\n<p>下面命令可以查看当前运行的Shell</p>\n<pre class=\"prettyprint\"><code>echo $SHELL</code></pre><p>下面命令可以查看当前的Linux系统安装的所有Shell</p>\n<pre class=\"prettyprint\"><code>cat /etc/shells</code></pre>"},{"context":[{"title":"运维","link":"javascript:void(0)"},{"title":"docker","link":"/ops/docker.html"}],"content":"\n        <h3 id=\"Doker\">\n            <a href='#Doker' class='header-anchor'>#</a>\n            <span>Doker</span>\n        </h3>\n    <p>仓库<br>镜像<br>容器</p>\n<p>下载地址：<br>    win10之外：<br>        <a href=\"https://www.docker.com/products/docker-toolbox\">https://www.docker.com/products/docker-toolbox</a><br>    win10:<br>        <a href=\"https://www.docker.com/products/docker#/windows\">https://www.docker.com/products/docker#/windows</a></p>\n<p>拉取镜像：<br>    docker pull  [options] name [:TAG]<br>查看已拉取的镜像：<br>    docker images [OPTIONS] REPROSITORY [:TAG]<br>运行一个镜像<br>    docker run [OPTIONS] IMAGE [:TAG] [COMMAND] [ARG...]</p>\n<pre class=\"prettyprint\"><code>-d参数表示在后台运行，并会打印出镜像ID</code></pre><p>查看正在机器上运行的容器<br>    docker ps<br>在容器中运行一个命令<br>    docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</p>\n"},{"context":[{"title":"正则","link":"javascript:void(0)"},{"title":"正则","link":"/regexp/regexp.cmd.html"}],"content":"\n        <h1 id=\"正则\">\n            <a href='#正则' class='header-anchor'>#</a>\n            <span>正则</span>\n        </h1>\n    "}];

  var escapeHtml = function (html) {
    let str = html;
    str = str.replace(/&/g, '&amp;');
    str = str.replace(/</g, '&lt;');
    str = str.replace(/>/g, '&gt;');
    str = str.replace(/"/g, '&quot;');
    str = str.replace(/'/g, '&#039;');
    return str;
  }

  var clearHtml = function (html) {
    let str = html;
    str = str.replace(/&amp;/g, '');
    str = str.replace(/&lt;/g, '');
    str = str.replace(/&gt;/g, '');
    str = str.replace(/&quot;/g, '');
    str = str.replace(/&#039;/g, '');
    return str;
  }

  var randStr = function () {
    return Math.random().toString(36).substr(2);
  };

  var findTitle = function (ele) {
    var findPrevs = function (ele) {
      var children = $(ele).parent().children();
      var prevs = [];
      var findIt = false;
      children = Array.prototype.slice.call(children);
      children.forEach(function (subEle) {
        if ($(subEle).is($(ele))) {
          findIt = true;
        }
        if (findIt === false && $(subEle).text() != "") {
          prevs.push(subEle);
        }
      });
      return prevs;
    };

    var findH = function (eles) {
      var _eles = Array.prototype.slice.call(eles);
      _eles.reverse();
      var title = "";
      var id = "";
      _eles.forEach(function (item) {
        if (!title) {
          if (item.nodeName[0] === "H") {
            title = $(item).text();
            id = $(item).attr("id");
          }
        }
      });
      return {
        text: title,
        id: id
      };
    };
    var prevs = findPrevs(ele);
    if (prevs.length) {
      return findH(prevs);
    }
  };

  window.searchData = function (keyword) {
    var searchResult = [];
    content.forEach(function (item, index) {
      var tempHtml = "<div id='" + randStr() + "'></div>";
      var tempEle = $(tempHtml);
      var findArray = [];
      tempEle.html(clearHtml(item.content));
      findArray = tempEle.find(":contains('" + keyword + "')");
      findArray = Array.prototype.slice.call(findArray);
      if (findArray.length) {
        findArray.forEach(function (ele) {
          var findContent = $(ele).text();
          findContent = findContent[0] === "<" ? $(findContent).text() : findContent;
          findContent = escapeHtml(findContent);
          findContent = findContent.replace(new RegExp(keyword, 'g'), "<b>" + keyword + "</b>");
          var hObj = findTitle(ele);
          if (hObj) {
            searchResult.push({
              context: item.context,
              title: hObj.text,
              hid: hObj.id,
              findContent: findContent
            });
          }
        });
      }
    });
    return searchResult;
  };
})();